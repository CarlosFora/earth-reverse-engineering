// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/rocktree.proto

#ifndef PROTOBUF_INCLUDED_proto_2frocktree_2eproto
#define PROTOBUF_INCLUDED_proto_2frocktree_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2frocktree_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2frocktree_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_proto_2frocktree_2eproto();
namespace geo_globetrotter_proto_rocktree {
class BulkMetadata;
class BulkMetadataDefaultTypeInternal;
extern BulkMetadataDefaultTypeInternal _BulkMetadata_default_instance_;
class BulkMetadataRequest;
class BulkMetadataRequestDefaultTypeInternal;
extern BulkMetadataRequestDefaultTypeInternal _BulkMetadataRequest_default_instance_;
class Copyright;
class CopyrightDefaultTypeInternal;
extern CopyrightDefaultTypeInternal _Copyright_default_instance_;
class CopyrightRequest;
class CopyrightRequestDefaultTypeInternal;
extern CopyrightRequestDefaultTypeInternal _CopyrightRequest_default_instance_;
class Copyrights;
class CopyrightsDefaultTypeInternal;
extern CopyrightsDefaultTypeInternal _Copyrights_default_instance_;
class Mesh;
class MeshDefaultTypeInternal;
extern MeshDefaultTypeInternal _Mesh_default_instance_;
class NodeData;
class NodeDataDefaultTypeInternal;
extern NodeDataDefaultTypeInternal _NodeData_default_instance_;
class NodeDataRequest;
class NodeDataRequestDefaultTypeInternal;
extern NodeDataRequestDefaultTypeInternal _NodeDataRequest_default_instance_;
class NodeKey;
class NodeKeyDefaultTypeInternal;
extern NodeKeyDefaultTypeInternal _NodeKey_default_instance_;
class NodeMetadata;
class NodeMetadataDefaultTypeInternal;
extern NodeMetadataDefaultTypeInternal _NodeMetadata_default_instance_;
class PlanetoidMetadata;
class PlanetoidMetadataDefaultTypeInternal;
extern PlanetoidMetadataDefaultTypeInternal _PlanetoidMetadata_default_instance_;
class Texture;
class TextureDefaultTypeInternal;
extern TextureDefaultTypeInternal _Texture_default_instance_;
class TextureData;
class TextureDataDefaultTypeInternal;
extern TextureDataDefaultTypeInternal _TextureData_default_instance_;
class TextureDataRequest;
class TextureDataRequestDefaultTypeInternal;
extern TextureDataRequestDefaultTypeInternal _TextureDataRequest_default_instance_;
}  // namespace geo_globetrotter_proto_rocktree
namespace google {
namespace protobuf {
template<> ::geo_globetrotter_proto_rocktree::BulkMetadata* Arena::CreateMaybeMessage<::geo_globetrotter_proto_rocktree::BulkMetadata>(Arena*);
template<> ::geo_globetrotter_proto_rocktree::BulkMetadataRequest* Arena::CreateMaybeMessage<::geo_globetrotter_proto_rocktree::BulkMetadataRequest>(Arena*);
template<> ::geo_globetrotter_proto_rocktree::Copyright* Arena::CreateMaybeMessage<::geo_globetrotter_proto_rocktree::Copyright>(Arena*);
template<> ::geo_globetrotter_proto_rocktree::CopyrightRequest* Arena::CreateMaybeMessage<::geo_globetrotter_proto_rocktree::CopyrightRequest>(Arena*);
template<> ::geo_globetrotter_proto_rocktree::Copyrights* Arena::CreateMaybeMessage<::geo_globetrotter_proto_rocktree::Copyrights>(Arena*);
template<> ::geo_globetrotter_proto_rocktree::Mesh* Arena::CreateMaybeMessage<::geo_globetrotter_proto_rocktree::Mesh>(Arena*);
template<> ::geo_globetrotter_proto_rocktree::NodeData* Arena::CreateMaybeMessage<::geo_globetrotter_proto_rocktree::NodeData>(Arena*);
template<> ::geo_globetrotter_proto_rocktree::NodeDataRequest* Arena::CreateMaybeMessage<::geo_globetrotter_proto_rocktree::NodeDataRequest>(Arena*);
template<> ::geo_globetrotter_proto_rocktree::NodeKey* Arena::CreateMaybeMessage<::geo_globetrotter_proto_rocktree::NodeKey>(Arena*);
template<> ::geo_globetrotter_proto_rocktree::NodeMetadata* Arena::CreateMaybeMessage<::geo_globetrotter_proto_rocktree::NodeMetadata>(Arena*);
template<> ::geo_globetrotter_proto_rocktree::PlanetoidMetadata* Arena::CreateMaybeMessage<::geo_globetrotter_proto_rocktree::PlanetoidMetadata>(Arena*);
template<> ::geo_globetrotter_proto_rocktree::Texture* Arena::CreateMaybeMessage<::geo_globetrotter_proto_rocktree::Texture>(Arena*);
template<> ::geo_globetrotter_proto_rocktree::TextureData* Arena::CreateMaybeMessage<::geo_globetrotter_proto_rocktree::TextureData>(Arena*);
template<> ::geo_globetrotter_proto_rocktree::TextureDataRequest* Arena::CreateMaybeMessage<::geo_globetrotter_proto_rocktree::TextureDataRequest>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace geo_globetrotter_proto_rocktree {

enum NodeMetadata_Flags {
  NodeMetadata_Flags_RICH3D_LEAF = 1,
  NodeMetadata_Flags_RICH3D_NODATA = 2,
  NodeMetadata_Flags_LEAF = 4,
  NodeMetadata_Flags_NODATA = 8,
  NodeMetadata_Flags_USE_IMAGERY_EPOCH = 16
};
bool NodeMetadata_Flags_IsValid(int value);
const NodeMetadata_Flags NodeMetadata_Flags_Flags_MIN = NodeMetadata_Flags_RICH3D_LEAF;
const NodeMetadata_Flags NodeMetadata_Flags_Flags_MAX = NodeMetadata_Flags_USE_IMAGERY_EPOCH;
const int NodeMetadata_Flags_Flags_ARRAYSIZE = NodeMetadata_Flags_Flags_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeMetadata_Flags_descriptor();
inline const ::std::string& NodeMetadata_Flags_Name(NodeMetadata_Flags value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeMetadata_Flags_descriptor(), value);
}
inline bool NodeMetadata_Flags_Parse(
    const ::std::string& name, NodeMetadata_Flags* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeMetadata_Flags>(
    NodeMetadata_Flags_descriptor(), name, value);
}
enum Mesh_Layer {
  Mesh_Layer_OVERGROUND = 0,
  Mesh_Layer_TERRAIN_BELOW_WATER = 1,
  Mesh_Layer_TERRAIN_ABOVE_WATER = 2,
  Mesh_Layer_TERRAIN_HIDDEN = 3,
  Mesh_Layer_WATER = 4,
  Mesh_Layer_WATER_SKIRTS = 5,
  Mesh_Layer_WATER_SKIRTS_INVERTED = 6,
  Mesh_Layer_OVERLAY_SURFACE = 7,
  Mesh_Layer_OVERLAY_SURFACE_SKIRTS = 8,
  Mesh_Layer_NUM_LAYERS = 9
};
bool Mesh_Layer_IsValid(int value);
const Mesh_Layer Mesh_Layer_Layer_MIN = Mesh_Layer_OVERGROUND;
const Mesh_Layer Mesh_Layer_Layer_MAX = Mesh_Layer_NUM_LAYERS;
const int Mesh_Layer_Layer_ARRAYSIZE = Mesh_Layer_Layer_MAX + 1;

const ::google::protobuf::EnumDescriptor* Mesh_Layer_descriptor();
inline const ::std::string& Mesh_Layer_Name(Mesh_Layer value) {
  return ::google::protobuf::internal::NameOfEnum(
    Mesh_Layer_descriptor(), value);
}
inline bool Mesh_Layer_Parse(
    const ::std::string& name, Mesh_Layer* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Mesh_Layer>(
    Mesh_Layer_descriptor(), name, value);
}
enum Mesh_LayerMask {
  Mesh_LayerMask_TERRAIN_WITH_OVERGROUND = 7,
  Mesh_LayerMask_TERRAIN_WITH_WATER = 28,
  Mesh_LayerMask_TERRAIN_WITHOUT_WATER = 14
};
bool Mesh_LayerMask_IsValid(int value);
const Mesh_LayerMask Mesh_LayerMask_LayerMask_MIN = Mesh_LayerMask_TERRAIN_WITH_OVERGROUND;
const Mesh_LayerMask Mesh_LayerMask_LayerMask_MAX = Mesh_LayerMask_TERRAIN_WITH_WATER;
const int Mesh_LayerMask_LayerMask_ARRAYSIZE = Mesh_LayerMask_LayerMask_MAX + 1;

const ::google::protobuf::EnumDescriptor* Mesh_LayerMask_descriptor();
inline const ::std::string& Mesh_LayerMask_Name(Mesh_LayerMask value) {
  return ::google::protobuf::internal::NameOfEnum(
    Mesh_LayerMask_descriptor(), value);
}
inline bool Mesh_LayerMask_Parse(
    const ::std::string& name, Mesh_LayerMask* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Mesh_LayerMask>(
    Mesh_LayerMask_descriptor(), name, value);
}
enum Texture_Format {
  Texture_Format_JPG = 1,
  Texture_Format_DXT1 = 2,
  Texture_Format_ETC1 = 3,
  Texture_Format_PVRTC2 = 4,
  Texture_Format_PVRTC4 = 5,
  Texture_Format_CRN_DXT1 = 6
};
bool Texture_Format_IsValid(int value);
const Texture_Format Texture_Format_Format_MIN = Texture_Format_JPG;
const Texture_Format Texture_Format_Format_MAX = Texture_Format_CRN_DXT1;
const int Texture_Format_Format_ARRAYSIZE = Texture_Format_Format_MAX + 1;

const ::google::protobuf::EnumDescriptor* Texture_Format_descriptor();
inline const ::std::string& Texture_Format_Name(Texture_Format value) {
  return ::google::protobuf::internal::NameOfEnum(
    Texture_Format_descriptor(), value);
}
inline bool Texture_Format_Parse(
    const ::std::string& name, Texture_Format* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Texture_Format>(
    Texture_Format_descriptor(), name, value);
}
enum Texture_ViewDirection {
  Texture_ViewDirection_NADIR = 0,
  Texture_ViewDirection_NORTH_45 = 1,
  Texture_ViewDirection_EAST_45 = 2,
  Texture_ViewDirection_SOUTH_45 = 3,
  Texture_ViewDirection_WEST_45 = 4
};
bool Texture_ViewDirection_IsValid(int value);
const Texture_ViewDirection Texture_ViewDirection_ViewDirection_MIN = Texture_ViewDirection_NADIR;
const Texture_ViewDirection Texture_ViewDirection_ViewDirection_MAX = Texture_ViewDirection_WEST_45;
const int Texture_ViewDirection_ViewDirection_ARRAYSIZE = Texture_ViewDirection_ViewDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* Texture_ViewDirection_descriptor();
inline const ::std::string& Texture_ViewDirection_Name(Texture_ViewDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    Texture_ViewDirection_descriptor(), value);
}
inline bool Texture_ViewDirection_Parse(
    const ::std::string& name, Texture_ViewDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Texture_ViewDirection>(
    Texture_ViewDirection_descriptor(), name, value);
}
// ===================================================================

class BulkMetadataRequest :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geo_globetrotter_proto_rocktree.BulkMetadataRequest) */ {
 public:
  BulkMetadataRequest();
  virtual ~BulkMetadataRequest();

  BulkMetadataRequest(const BulkMetadataRequest& from);

  inline BulkMetadataRequest& operator=(const BulkMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BulkMetadataRequest(BulkMetadataRequest&& from) noexcept
    : BulkMetadataRequest() {
    *this = ::std::move(from);
  }

  inline BulkMetadataRequest& operator=(BulkMetadataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BulkMetadataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BulkMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const BulkMetadataRequest*>(
               &_BulkMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(BulkMetadataRequest* other);
  friend void swap(BulkMetadataRequest& a, BulkMetadataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BulkMetadataRequest* New() const final {
    return CreateMaybeMessage<BulkMetadataRequest>(nullptr);
  }

  BulkMetadataRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BulkMetadataRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BulkMetadataRequest& from);
  void MergeFrom(const BulkMetadataRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulkMetadataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .geo_globetrotter_proto_rocktree.NodeKey node_key = 1;
  bool has_node_key() const;
  void clear_node_key();
  static const int kNodeKeyFieldNumber = 1;
  const ::geo_globetrotter_proto_rocktree::NodeKey& node_key() const;
  ::geo_globetrotter_proto_rocktree::NodeKey* release_node_key();
  ::geo_globetrotter_proto_rocktree::NodeKey* mutable_node_key();
  void set_allocated_node_key(::geo_globetrotter_proto_rocktree::NodeKey* node_key);

  // @@protoc_insertion_point(class_scope:geo_globetrotter_proto_rocktree.BulkMetadataRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::geo_globetrotter_proto_rocktree::NodeKey* node_key_;
  friend struct ::TableStruct_proto_2frocktree_2eproto;
};
// -------------------------------------------------------------------

class NodeDataRequest :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geo_globetrotter_proto_rocktree.NodeDataRequest) */ {
 public:
  NodeDataRequest();
  virtual ~NodeDataRequest();

  NodeDataRequest(const NodeDataRequest& from);

  inline NodeDataRequest& operator=(const NodeDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeDataRequest(NodeDataRequest&& from) noexcept
    : NodeDataRequest() {
    *this = ::std::move(from);
  }

  inline NodeDataRequest& operator=(NodeDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NodeDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeDataRequest* internal_default_instance() {
    return reinterpret_cast<const NodeDataRequest*>(
               &_NodeDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(NodeDataRequest* other);
  friend void swap(NodeDataRequest& a, NodeDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeDataRequest* New() const final {
    return CreateMaybeMessage<NodeDataRequest>(nullptr);
  }

  NodeDataRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeDataRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeDataRequest& from);
  void MergeFrom(const NodeDataRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .geo_globetrotter_proto_rocktree.NodeKey node_key = 1;
  bool has_node_key() const;
  void clear_node_key();
  static const int kNodeKeyFieldNumber = 1;
  const ::geo_globetrotter_proto_rocktree::NodeKey& node_key() const;
  ::geo_globetrotter_proto_rocktree::NodeKey* release_node_key();
  ::geo_globetrotter_proto_rocktree::NodeKey* mutable_node_key();
  void set_allocated_node_key(::geo_globetrotter_proto_rocktree::NodeKey* node_key);

  // optional uint32 imagery_epoch = 3;
  bool has_imagery_epoch() const;
  void clear_imagery_epoch();
  static const int kImageryEpochFieldNumber = 3;
  ::google::protobuf::uint32 imagery_epoch() const;
  void set_imagery_epoch(::google::protobuf::uint32 value);

  // optional .geo_globetrotter_proto_rocktree.Texture.Format texture_format = 2;
  bool has_texture_format() const;
  void clear_texture_format();
  static const int kTextureFormatFieldNumber = 2;
  ::geo_globetrotter_proto_rocktree::Texture_Format texture_format() const;
  void set_texture_format(::geo_globetrotter_proto_rocktree::Texture_Format value);

  // @@protoc_insertion_point(class_scope:geo_globetrotter_proto_rocktree.NodeDataRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::geo_globetrotter_proto_rocktree::NodeKey* node_key_;
  ::google::protobuf::uint32 imagery_epoch_;
  int texture_format_;
  friend struct ::TableStruct_proto_2frocktree_2eproto;
};
// -------------------------------------------------------------------

class NodeKey :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geo_globetrotter_proto_rocktree.NodeKey) */ {
 public:
  NodeKey();
  virtual ~NodeKey();

  NodeKey(const NodeKey& from);

  inline NodeKey& operator=(const NodeKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeKey(NodeKey&& from) noexcept
    : NodeKey() {
    *this = ::std::move(from);
  }

  inline NodeKey& operator=(NodeKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NodeKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeKey* internal_default_instance() {
    return reinterpret_cast<const NodeKey*>(
               &_NodeKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(NodeKey* other);
  friend void swap(NodeKey& a, NodeKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeKey* New() const final {
    return CreateMaybeMessage<NodeKey>(nullptr);
  }

  NodeKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeKey& from);
  void MergeFrom(const NodeKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // optional uint32 epoch = 2;
  bool has_epoch() const;
  void clear_epoch();
  static const int kEpochFieldNumber = 2;
  ::google::protobuf::uint32 epoch() const;
  void set_epoch(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:geo_globetrotter_proto_rocktree.NodeKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::uint32 epoch_;
  friend struct ::TableStruct_proto_2frocktree_2eproto;
};
// -------------------------------------------------------------------

class CopyrightRequest :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geo_globetrotter_proto_rocktree.CopyrightRequest) */ {
 public:
  CopyrightRequest();
  virtual ~CopyrightRequest();

  CopyrightRequest(const CopyrightRequest& from);

  inline CopyrightRequest& operator=(const CopyrightRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CopyrightRequest(CopyrightRequest&& from) noexcept
    : CopyrightRequest() {
    *this = ::std::move(from);
  }

  inline CopyrightRequest& operator=(CopyrightRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CopyrightRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CopyrightRequest* internal_default_instance() {
    return reinterpret_cast<const CopyrightRequest*>(
               &_CopyrightRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(CopyrightRequest* other);
  friend void swap(CopyrightRequest& a, CopyrightRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CopyrightRequest* New() const final {
    return CreateMaybeMessage<CopyrightRequest>(nullptr);
  }

  CopyrightRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CopyrightRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CopyrightRequest& from);
  void MergeFrom(const CopyrightRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CopyrightRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 epoch = 1;
  bool has_epoch() const;
  void clear_epoch();
  static const int kEpochFieldNumber = 1;
  ::google::protobuf::uint32 epoch() const;
  void set_epoch(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:geo_globetrotter_proto_rocktree.CopyrightRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 epoch_;
  friend struct ::TableStruct_proto_2frocktree_2eproto;
};
// -------------------------------------------------------------------

class TextureDataRequest :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geo_globetrotter_proto_rocktree.TextureDataRequest) */ {
 public:
  TextureDataRequest();
  virtual ~TextureDataRequest();

  TextureDataRequest(const TextureDataRequest& from);

  inline TextureDataRequest& operator=(const TextureDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TextureDataRequest(TextureDataRequest&& from) noexcept
    : TextureDataRequest() {
    *this = ::std::move(from);
  }

  inline TextureDataRequest& operator=(TextureDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TextureDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextureDataRequest* internal_default_instance() {
    return reinterpret_cast<const TextureDataRequest*>(
               &_TextureDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(TextureDataRequest* other);
  friend void swap(TextureDataRequest& a, TextureDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TextureDataRequest* New() const final {
    return CreateMaybeMessage<TextureDataRequest>(nullptr);
  }

  TextureDataRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TextureDataRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TextureDataRequest& from);
  void MergeFrom(const TextureDataRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextureDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .geo_globetrotter_proto_rocktree.NodeKey node_key = 1;
  bool has_node_key() const;
  void clear_node_key();
  static const int kNodeKeyFieldNumber = 1;
  const ::geo_globetrotter_proto_rocktree::NodeKey& node_key() const;
  ::geo_globetrotter_proto_rocktree::NodeKey* release_node_key();
  ::geo_globetrotter_proto_rocktree::NodeKey* mutable_node_key();
  void set_allocated_node_key(::geo_globetrotter_proto_rocktree::NodeKey* node_key);

  // optional .geo_globetrotter_proto_rocktree.Texture.ViewDirection view_direction = 3;
  bool has_view_direction() const;
  void clear_view_direction();
  static const int kViewDirectionFieldNumber = 3;
  ::geo_globetrotter_proto_rocktree::Texture_ViewDirection view_direction() const;
  void set_view_direction(::geo_globetrotter_proto_rocktree::Texture_ViewDirection value);

  // optional .geo_globetrotter_proto_rocktree.Texture.Format texture_format = 2;
  bool has_texture_format() const;
  void clear_texture_format();
  static const int kTextureFormatFieldNumber = 2;
  ::geo_globetrotter_proto_rocktree::Texture_Format texture_format() const;
  void set_texture_format(::geo_globetrotter_proto_rocktree::Texture_Format value);

  // @@protoc_insertion_point(class_scope:geo_globetrotter_proto_rocktree.TextureDataRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::geo_globetrotter_proto_rocktree::NodeKey* node_key_;
  int view_direction_;
  int texture_format_;
  friend struct ::TableStruct_proto_2frocktree_2eproto;
};
// -------------------------------------------------------------------

class BulkMetadata :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geo_globetrotter_proto_rocktree.BulkMetadata) */ {
 public:
  BulkMetadata();
  virtual ~BulkMetadata();

  BulkMetadata(const BulkMetadata& from);

  inline BulkMetadata& operator=(const BulkMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BulkMetadata(BulkMetadata&& from) noexcept
    : BulkMetadata() {
    *this = ::std::move(from);
  }

  inline BulkMetadata& operator=(BulkMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BulkMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BulkMetadata* internal_default_instance() {
    return reinterpret_cast<const BulkMetadata*>(
               &_BulkMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(BulkMetadata* other);
  friend void swap(BulkMetadata& a, BulkMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BulkMetadata* New() const final {
    return CreateMaybeMessage<BulkMetadata>(nullptr);
  }

  BulkMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BulkMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BulkMetadata& from);
  void MergeFrom(const BulkMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulkMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .geo_globetrotter_proto_rocktree.NodeMetadata node_metadata = 1;
  int node_metadata_size() const;
  void clear_node_metadata();
  static const int kNodeMetadataFieldNumber = 1;
  ::geo_globetrotter_proto_rocktree::NodeMetadata* mutable_node_metadata(int index);
  ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::NodeMetadata >*
      mutable_node_metadata();
  const ::geo_globetrotter_proto_rocktree::NodeMetadata& node_metadata(int index) const;
  ::geo_globetrotter_proto_rocktree::NodeMetadata* add_node_metadata();
  const ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::NodeMetadata >&
      node_metadata() const;

  // repeated double head_node_center = 3 [packed = true];
  int head_node_center_size() const;
  void clear_head_node_center();
  static const int kHeadNodeCenterFieldNumber = 3;
  double head_node_center(int index) const;
  void set_head_node_center(int index, double value);
  void add_head_node_center(double value);
  const ::google::protobuf::RepeatedField< double >&
      head_node_center() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_head_node_center();

  // repeated float meters_per_texel = 4 [packed = true];
  int meters_per_texel_size() const;
  void clear_meters_per_texel();
  static const int kMetersPerTexelFieldNumber = 4;
  float meters_per_texel(int index) const;
  void set_meters_per_texel(int index, float value);
  void add_meters_per_texel(float value);
  const ::google::protobuf::RepeatedField< float >&
      meters_per_texel() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_meters_per_texel();

  // optional .geo_globetrotter_proto_rocktree.NodeKey head_node_key = 2;
  bool has_head_node_key() const;
  void clear_head_node_key();
  static const int kHeadNodeKeyFieldNumber = 2;
  const ::geo_globetrotter_proto_rocktree::NodeKey& head_node_key() const;
  ::geo_globetrotter_proto_rocktree::NodeKey* release_head_node_key();
  ::geo_globetrotter_proto_rocktree::NodeKey* mutable_head_node_key();
  void set_allocated_head_node_key(::geo_globetrotter_proto_rocktree::NodeKey* head_node_key);

  // optional uint32 default_imagery_epoch = 5;
  bool has_default_imagery_epoch() const;
  void clear_default_imagery_epoch();
  static const int kDefaultImageryEpochFieldNumber = 5;
  ::google::protobuf::uint32 default_imagery_epoch() const;
  void set_default_imagery_epoch(::google::protobuf::uint32 value);

  // optional uint32 default_available_texture_formats = 6;
  bool has_default_available_texture_formats() const;
  void clear_default_available_texture_formats();
  static const int kDefaultAvailableTextureFormatsFieldNumber = 6;
  ::google::protobuf::uint32 default_available_texture_formats() const;
  void set_default_available_texture_formats(::google::protobuf::uint32 value);

  // optional uint32 default_available_view_dependent_textures = 7;
  bool has_default_available_view_dependent_textures() const;
  void clear_default_available_view_dependent_textures();
  static const int kDefaultAvailableViewDependentTexturesFieldNumber = 7;
  ::google::protobuf::uint32 default_available_view_dependent_textures() const;
  void set_default_available_view_dependent_textures(::google::protobuf::uint32 value);

  // optional uint32 default_available_view_dependent_texture_formats = 8;
  bool has_default_available_view_dependent_texture_formats() const;
  void clear_default_available_view_dependent_texture_formats();
  static const int kDefaultAvailableViewDependentTextureFormatsFieldNumber = 8;
  ::google::protobuf::uint32 default_available_view_dependent_texture_formats() const;
  void set_default_available_view_dependent_texture_formats(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:geo_globetrotter_proto_rocktree.BulkMetadata)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::NodeMetadata > node_metadata_;
  ::google::protobuf::RepeatedField< double > head_node_center_;
  mutable std::atomic<int> _head_node_center_cached_byte_size_;
  ::google::protobuf::RepeatedField< float > meters_per_texel_;
  mutable std::atomic<int> _meters_per_texel_cached_byte_size_;
  ::geo_globetrotter_proto_rocktree::NodeKey* head_node_key_;
  ::google::protobuf::uint32 default_imagery_epoch_;
  ::google::protobuf::uint32 default_available_texture_formats_;
  ::google::protobuf::uint32 default_available_view_dependent_textures_;
  ::google::protobuf::uint32 default_available_view_dependent_texture_formats_;
  friend struct ::TableStruct_proto_2frocktree_2eproto;
};
// -------------------------------------------------------------------

class NodeMetadata :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geo_globetrotter_proto_rocktree.NodeMetadata) */ {
 public:
  NodeMetadata();
  virtual ~NodeMetadata();

  NodeMetadata(const NodeMetadata& from);

  inline NodeMetadata& operator=(const NodeMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeMetadata(NodeMetadata&& from) noexcept
    : NodeMetadata() {
    *this = ::std::move(from);
  }

  inline NodeMetadata& operator=(NodeMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NodeMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeMetadata* internal_default_instance() {
    return reinterpret_cast<const NodeMetadata*>(
               &_NodeMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(NodeMetadata* other);
  friend void swap(NodeMetadata& a, NodeMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeMetadata* New() const final {
    return CreateMaybeMessage<NodeMetadata>(nullptr);
  }

  NodeMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeMetadata& from);
  void MergeFrom(const NodeMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NodeMetadata_Flags Flags;
  static const Flags RICH3D_LEAF =
    NodeMetadata_Flags_RICH3D_LEAF;
  static const Flags RICH3D_NODATA =
    NodeMetadata_Flags_RICH3D_NODATA;
  static const Flags LEAF =
    NodeMetadata_Flags_LEAF;
  static const Flags NODATA =
    NodeMetadata_Flags_NODATA;
  static const Flags USE_IMAGERY_EPOCH =
    NodeMetadata_Flags_USE_IMAGERY_EPOCH;
  static inline bool Flags_IsValid(int value) {
    return NodeMetadata_Flags_IsValid(value);
  }
  static const Flags Flags_MIN =
    NodeMetadata_Flags_Flags_MIN;
  static const Flags Flags_MAX =
    NodeMetadata_Flags_Flags_MAX;
  static const int Flags_ARRAYSIZE =
    NodeMetadata_Flags_Flags_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Flags_descriptor() {
    return NodeMetadata_Flags_descriptor();
  }
  static inline const ::std::string& Flags_Name(Flags value) {
    return NodeMetadata_Flags_Name(value);
  }
  static inline bool Flags_Parse(const ::std::string& name,
      Flags* value) {
    return NodeMetadata_Flags_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated double processing_oriented_bounding_box = 6 [packed = true];
  int processing_oriented_bounding_box_size() const;
  void clear_processing_oriented_bounding_box();
  static const int kProcessingOrientedBoundingBoxFieldNumber = 6;
  double processing_oriented_bounding_box(int index) const;
  void set_processing_oriented_bounding_box(int index, double value);
  void add_processing_oriented_bounding_box(double value);
  const ::google::protobuf::RepeatedField< double >&
      processing_oriented_bounding_box() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_processing_oriented_bounding_box();

  // optional bytes oriented_bounding_box = 3;
  bool has_oriented_bounding_box() const;
  void clear_oriented_bounding_box();
  static const int kOrientedBoundingBoxFieldNumber = 3;
  const ::std::string& oriented_bounding_box() const;
  void set_oriented_bounding_box(const ::std::string& value);
  #if LANG_CXX11
  void set_oriented_bounding_box(::std::string&& value);
  #endif
  void set_oriented_bounding_box(const char* value);
  void set_oriented_bounding_box(const void* value, size_t size);
  ::std::string* mutable_oriented_bounding_box();
  ::std::string* release_oriented_bounding_box();
  void set_allocated_oriented_bounding_box(::std::string* oriented_bounding_box);

  // optional uint32 path_and_flags = 1;
  bool has_path_and_flags() const;
  void clear_path_and_flags();
  static const int kPathAndFlagsFieldNumber = 1;
  ::google::protobuf::uint32 path_and_flags() const;
  void set_path_and_flags(::google::protobuf::uint32 value);

  // optional uint32 epoch = 2;
  bool has_epoch() const;
  void clear_epoch();
  static const int kEpochFieldNumber = 2;
  ::google::protobuf::uint32 epoch() const;
  void set_epoch(::google::protobuf::uint32 value);

  // optional float meters_per_texel = 4;
  bool has_meters_per_texel() const;
  void clear_meters_per_texel();
  static const int kMetersPerTexelFieldNumber = 4;
  float meters_per_texel() const;
  void set_meters_per_texel(float value);

  // optional uint32 bulk_metadata_epoch = 5;
  bool has_bulk_metadata_epoch() const;
  void clear_bulk_metadata_epoch();
  static const int kBulkMetadataEpochFieldNumber = 5;
  ::google::protobuf::uint32 bulk_metadata_epoch() const;
  void set_bulk_metadata_epoch(::google::protobuf::uint32 value);

  // optional uint32 imagery_epoch = 7;
  bool has_imagery_epoch() const;
  void clear_imagery_epoch();
  static const int kImageryEpochFieldNumber = 7;
  ::google::protobuf::uint32 imagery_epoch() const;
  void set_imagery_epoch(::google::protobuf::uint32 value);

  // optional uint32 available_texture_formats = 8;
  bool has_available_texture_formats() const;
  void clear_available_texture_formats();
  static const int kAvailableTextureFormatsFieldNumber = 8;
  ::google::protobuf::uint32 available_texture_formats() const;
  void set_available_texture_formats(::google::protobuf::uint32 value);

  // optional uint32 available_view_dependent_textures = 9;
  bool has_available_view_dependent_textures() const;
  void clear_available_view_dependent_textures();
  static const int kAvailableViewDependentTexturesFieldNumber = 9;
  ::google::protobuf::uint32 available_view_dependent_textures() const;
  void set_available_view_dependent_textures(::google::protobuf::uint32 value);

  // optional uint32 available_view_dependent_texture_formats = 10;
  bool has_available_view_dependent_texture_formats() const;
  void clear_available_view_dependent_texture_formats();
  static const int kAvailableViewDependentTextureFormatsFieldNumber = 10;
  ::google::protobuf::uint32 available_view_dependent_texture_formats() const;
  void set_available_view_dependent_texture_formats(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:geo_globetrotter_proto_rocktree.NodeMetadata)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< double > processing_oriented_bounding_box_;
  mutable std::atomic<int> _processing_oriented_bounding_box_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr oriented_bounding_box_;
  ::google::protobuf::uint32 path_and_flags_;
  ::google::protobuf::uint32 epoch_;
  float meters_per_texel_;
  ::google::protobuf::uint32 bulk_metadata_epoch_;
  ::google::protobuf::uint32 imagery_epoch_;
  ::google::protobuf::uint32 available_texture_formats_;
  ::google::protobuf::uint32 available_view_dependent_textures_;
  ::google::protobuf::uint32 available_view_dependent_texture_formats_;
  friend struct ::TableStruct_proto_2frocktree_2eproto;
};
// -------------------------------------------------------------------

class NodeData :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geo_globetrotter_proto_rocktree.NodeData) */ {
 public:
  NodeData();
  virtual ~NodeData();

  NodeData(const NodeData& from);

  inline NodeData& operator=(const NodeData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeData(NodeData&& from) noexcept
    : NodeData() {
    *this = ::std::move(from);
  }

  inline NodeData& operator=(NodeData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NodeData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeData* internal_default_instance() {
    return reinterpret_cast<const NodeData*>(
               &_NodeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(NodeData* other);
  friend void swap(NodeData& a, NodeData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeData* New() const final {
    return CreateMaybeMessage<NodeData>(nullptr);
  }

  NodeData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeData& from);
  void MergeFrom(const NodeData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double matrix_globe_from_mesh = 1 [packed = true];
  int matrix_globe_from_mesh_size() const;
  void clear_matrix_globe_from_mesh();
  static const int kMatrixGlobeFromMeshFieldNumber = 1;
  double matrix_globe_from_mesh(int index) const;
  void set_matrix_globe_from_mesh(int index, double value);
  void add_matrix_globe_from_mesh(double value);
  const ::google::protobuf::RepeatedField< double >&
      matrix_globe_from_mesh() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_matrix_globe_from_mesh();

  // repeated .geo_globetrotter_proto_rocktree.Mesh meshes = 2;
  int meshes_size() const;
  void clear_meshes();
  static const int kMeshesFieldNumber = 2;
  ::geo_globetrotter_proto_rocktree::Mesh* mutable_meshes(int index);
  ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Mesh >*
      mutable_meshes();
  const ::geo_globetrotter_proto_rocktree::Mesh& meshes(int index) const;
  ::geo_globetrotter_proto_rocktree::Mesh* add_meshes();
  const ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Mesh >&
      meshes() const;

  // repeated uint32 copyright_ids = 3;
  int copyright_ids_size() const;
  void clear_copyright_ids();
  static const int kCopyrightIdsFieldNumber = 3;
  ::google::protobuf::uint32 copyright_ids(int index) const;
  void set_copyright_ids(int index, ::google::protobuf::uint32 value);
  void add_copyright_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      copyright_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_copyright_ids();

  // repeated double kml_bounding_box = 5 [packed = true];
  int kml_bounding_box_size() const;
  void clear_kml_bounding_box();
  static const int kKmlBoundingBoxFieldNumber = 5;
  double kml_bounding_box(int index) const;
  void set_kml_bounding_box(int index, double value);
  void add_kml_bounding_box(double value);
  const ::google::protobuf::RepeatedField< double >&
      kml_bounding_box() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_kml_bounding_box();

  // repeated .geo_globetrotter_proto_rocktree.Mesh overlay_surface_meshes = 7;
  int overlay_surface_meshes_size() const;
  void clear_overlay_surface_meshes();
  static const int kOverlaySurfaceMeshesFieldNumber = 7;
  ::geo_globetrotter_proto_rocktree::Mesh* mutable_overlay_surface_meshes(int index);
  ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Mesh >*
      mutable_overlay_surface_meshes();
  const ::geo_globetrotter_proto_rocktree::Mesh& overlay_surface_meshes(int index) const;
  ::geo_globetrotter_proto_rocktree::Mesh* add_overlay_surface_meshes();
  const ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Mesh >&
      overlay_surface_meshes() const;

  // optional .geo_globetrotter_proto_rocktree.NodeKey node_key = 4;
  bool has_node_key() const;
  void clear_node_key();
  static const int kNodeKeyFieldNumber = 4;
  const ::geo_globetrotter_proto_rocktree::NodeKey& node_key() const;
  ::geo_globetrotter_proto_rocktree::NodeKey* release_node_key();
  ::geo_globetrotter_proto_rocktree::NodeKey* mutable_node_key();
  void set_allocated_node_key(::geo_globetrotter_proto_rocktree::NodeKey* node_key);

  // optional .geo_globetrotter_proto_rocktree.Mesh water_mesh = 6;
  bool has_water_mesh() const;
  void clear_water_mesh();
  static const int kWaterMeshFieldNumber = 6;
  const ::geo_globetrotter_proto_rocktree::Mesh& water_mesh() const;
  ::geo_globetrotter_proto_rocktree::Mesh* release_water_mesh();
  ::geo_globetrotter_proto_rocktree::Mesh* mutable_water_mesh();
  void set_allocated_water_mesh(::geo_globetrotter_proto_rocktree::Mesh* water_mesh);

  // @@protoc_insertion_point(class_scope:geo_globetrotter_proto_rocktree.NodeData)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< double > matrix_globe_from_mesh_;
  mutable std::atomic<int> _matrix_globe_from_mesh_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Mesh > meshes_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > copyright_ids_;
  ::google::protobuf::RepeatedField< double > kml_bounding_box_;
  mutable std::atomic<int> _kml_bounding_box_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Mesh > overlay_surface_meshes_;
  ::geo_globetrotter_proto_rocktree::NodeKey* node_key_;
  ::geo_globetrotter_proto_rocktree::Mesh* water_mesh_;
  friend struct ::TableStruct_proto_2frocktree_2eproto;
};
// -------------------------------------------------------------------

class Mesh :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geo_globetrotter_proto_rocktree.Mesh) */ {
 public:
  Mesh();
  virtual ~Mesh();

  Mesh(const Mesh& from);

  inline Mesh& operator=(const Mesh& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Mesh(Mesh&& from) noexcept
    : Mesh() {
    *this = ::std::move(from);
  }

  inline Mesh& operator=(Mesh&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Mesh& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mesh* internal_default_instance() {
    return reinterpret_cast<const Mesh*>(
               &_Mesh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Mesh* other);
  friend void swap(Mesh& a, Mesh& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Mesh* New() const final {
    return CreateMaybeMessage<Mesh>(nullptr);
  }

  Mesh* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Mesh>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Mesh& from);
  void MergeFrom(const Mesh& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mesh* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Mesh_Layer Layer;
  static const Layer OVERGROUND =
    Mesh_Layer_OVERGROUND;
  static const Layer TERRAIN_BELOW_WATER =
    Mesh_Layer_TERRAIN_BELOW_WATER;
  static const Layer TERRAIN_ABOVE_WATER =
    Mesh_Layer_TERRAIN_ABOVE_WATER;
  static const Layer TERRAIN_HIDDEN =
    Mesh_Layer_TERRAIN_HIDDEN;
  static const Layer WATER =
    Mesh_Layer_WATER;
  static const Layer WATER_SKIRTS =
    Mesh_Layer_WATER_SKIRTS;
  static const Layer WATER_SKIRTS_INVERTED =
    Mesh_Layer_WATER_SKIRTS_INVERTED;
  static const Layer OVERLAY_SURFACE =
    Mesh_Layer_OVERLAY_SURFACE;
  static const Layer OVERLAY_SURFACE_SKIRTS =
    Mesh_Layer_OVERLAY_SURFACE_SKIRTS;
  static const Layer NUM_LAYERS =
    Mesh_Layer_NUM_LAYERS;
  static inline bool Layer_IsValid(int value) {
    return Mesh_Layer_IsValid(value);
  }
  static const Layer Layer_MIN =
    Mesh_Layer_Layer_MIN;
  static const Layer Layer_MAX =
    Mesh_Layer_Layer_MAX;
  static const int Layer_ARRAYSIZE =
    Mesh_Layer_Layer_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Layer_descriptor() {
    return Mesh_Layer_descriptor();
  }
  static inline const ::std::string& Layer_Name(Layer value) {
    return Mesh_Layer_Name(value);
  }
  static inline bool Layer_Parse(const ::std::string& name,
      Layer* value) {
    return Mesh_Layer_Parse(name, value);
  }

  typedef Mesh_LayerMask LayerMask;
  static const LayerMask TERRAIN_WITH_OVERGROUND =
    Mesh_LayerMask_TERRAIN_WITH_OVERGROUND;
  static const LayerMask TERRAIN_WITH_WATER =
    Mesh_LayerMask_TERRAIN_WITH_WATER;
  static const LayerMask TERRAIN_WITHOUT_WATER =
    Mesh_LayerMask_TERRAIN_WITHOUT_WATER;
  static inline bool LayerMask_IsValid(int value) {
    return Mesh_LayerMask_IsValid(value);
  }
  static const LayerMask LayerMask_MIN =
    Mesh_LayerMask_LayerMask_MIN;
  static const LayerMask LayerMask_MAX =
    Mesh_LayerMask_LayerMask_MAX;
  static const int LayerMask_ARRAYSIZE =
    Mesh_LayerMask_LayerMask_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LayerMask_descriptor() {
    return Mesh_LayerMask_descriptor();
  }
  static inline const ::std::string& LayerMask_Name(LayerMask value) {
    return Mesh_LayerMask_Name(value);
  }
  static inline bool LayerMask_Parse(const ::std::string& name,
      LayerMask* value) {
    return Mesh_LayerMask_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .geo_globetrotter_proto_rocktree.Texture texture = 6;
  int texture_size() const;
  void clear_texture();
  static const int kTextureFieldNumber = 6;
  ::geo_globetrotter_proto_rocktree::Texture* mutable_texture(int index);
  ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Texture >*
      mutable_texture();
  const ::geo_globetrotter_proto_rocktree::Texture& texture(int index) const;
  ::geo_globetrotter_proto_rocktree::Texture* add_texture();
  const ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Texture >&
      texture() const;

  // repeated float uv_offset_and_scale = 10 [packed = true];
  int uv_offset_and_scale_size() const;
  void clear_uv_offset_and_scale();
  static const int kUvOffsetAndScaleFieldNumber = 10;
  float uv_offset_and_scale(int index) const;
  void set_uv_offset_and_scale(int index, float value);
  void add_uv_offset_and_scale(float value);
  const ::google::protobuf::RepeatedField< float >&
      uv_offset_and_scale() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_uv_offset_and_scale();

  // optional bytes vertices = 1;
  bool has_vertices() const;
  void clear_vertices();
  static const int kVerticesFieldNumber = 1;
  const ::std::string& vertices() const;
  void set_vertices(const ::std::string& value);
  #if LANG_CXX11
  void set_vertices(::std::string&& value);
  #endif
  void set_vertices(const char* value);
  void set_vertices(const void* value, size_t size);
  ::std::string* mutable_vertices();
  ::std::string* release_vertices();
  void set_allocated_vertices(::std::string* vertices);

  // optional bytes texture_coords = 2;
  bool has_texture_coords() const;
  void clear_texture_coords();
  static const int kTextureCoordsFieldNumber = 2;
  const ::std::string& texture_coords() const;
  void set_texture_coords(const ::std::string& value);
  #if LANG_CXX11
  void set_texture_coords(::std::string&& value);
  #endif
  void set_texture_coords(const char* value);
  void set_texture_coords(const void* value, size_t size);
  ::std::string* mutable_texture_coords();
  ::std::string* release_texture_coords();
  void set_allocated_texture_coords(::std::string* texture_coords);

  // optional bytes indices = 3;
  bool has_indices() const;
  void clear_indices();
  static const int kIndicesFieldNumber = 3;
  const ::std::string& indices() const;
  void set_indices(const ::std::string& value);
  #if LANG_CXX11
  void set_indices(::std::string&& value);
  #endif
  void set_indices(const char* value);
  void set_indices(const void* value, size_t size);
  ::std::string* mutable_indices();
  ::std::string* release_indices();
  void set_allocated_indices(::std::string* indices);

  // optional bytes octant_ranges = 4;
  bool has_octant_ranges() const;
  void clear_octant_ranges();
  static const int kOctantRangesFieldNumber = 4;
  const ::std::string& octant_ranges() const;
  void set_octant_ranges(const ::std::string& value);
  #if LANG_CXX11
  void set_octant_ranges(::std::string&& value);
  #endif
  void set_octant_ranges(const char* value);
  void set_octant_ranges(const void* value, size_t size);
  ::std::string* mutable_octant_ranges();
  ::std::string* release_octant_ranges();
  void set_allocated_octant_ranges(::std::string* octant_ranges);

  // optional bytes layer_counts = 5;
  bool has_layer_counts() const;
  void clear_layer_counts();
  static const int kLayerCountsFieldNumber = 5;
  const ::std::string& layer_counts() const;
  void set_layer_counts(const ::std::string& value);
  #if LANG_CXX11
  void set_layer_counts(::std::string&& value);
  #endif
  void set_layer_counts(const char* value);
  void set_layer_counts(const void* value, size_t size);
  ::std::string* mutable_layer_counts();
  ::std::string* release_layer_counts();
  void set_allocated_layer_counts(::std::string* layer_counts);

  // optional bytes texture_coordinates = 7;
  bool has_texture_coordinates() const;
  void clear_texture_coordinates();
  static const int kTextureCoordinatesFieldNumber = 7;
  const ::std::string& texture_coordinates() const;
  void set_texture_coordinates(const ::std::string& value);
  #if LANG_CXX11
  void set_texture_coordinates(::std::string&& value);
  #endif
  void set_texture_coordinates(const char* value);
  void set_texture_coordinates(const void* value, size_t size);
  ::std::string* mutable_texture_coordinates();
  ::std::string* release_texture_coordinates();
  void set_allocated_texture_coordinates(::std::string* texture_coordinates);

  // optional bytes layer_and_octant_counts = 8;
  bool has_layer_and_octant_counts() const;
  void clear_layer_and_octant_counts();
  static const int kLayerAndOctantCountsFieldNumber = 8;
  const ::std::string& layer_and_octant_counts() const;
  void set_layer_and_octant_counts(const ::std::string& value);
  #if LANG_CXX11
  void set_layer_and_octant_counts(::std::string&& value);
  #endif
  void set_layer_and_octant_counts(const char* value);
  void set_layer_and_octant_counts(const void* value, size_t size);
  ::std::string* mutable_layer_and_octant_counts();
  ::std::string* release_layer_and_octant_counts();
  void set_allocated_layer_and_octant_counts(::std::string* layer_and_octant_counts);

  // optional bytes vertex_alphas = 9;
  bool has_vertex_alphas() const;
  void clear_vertex_alphas();
  static const int kVertexAlphasFieldNumber = 9;
  const ::std::string& vertex_alphas() const;
  void set_vertex_alphas(const ::std::string& value);
  #if LANG_CXX11
  void set_vertex_alphas(::std::string&& value);
  #endif
  void set_vertex_alphas(const char* value);
  void set_vertex_alphas(const void* value, size_t size);
  ::std::string* mutable_vertex_alphas();
  ::std::string* release_vertex_alphas();
  void set_allocated_vertex_alphas(::std::string* vertex_alphas);

  // optional bytes normals = 11;
  bool has_normals() const;
  void clear_normals();
  static const int kNormalsFieldNumber = 11;
  const ::std::string& normals() const;
  void set_normals(const ::std::string& value);
  #if LANG_CXX11
  void set_normals(::std::string&& value);
  #endif
  void set_normals(const char* value);
  void set_normals(const void* value, size_t size);
  ::std::string* mutable_normals();
  ::std::string* release_normals();
  void set_allocated_normals(::std::string* normals);

  // optional bytes skirt_flags = 13;
  bool has_skirt_flags() const;
  void clear_skirt_flags();
  static const int kSkirtFlagsFieldNumber = 13;
  const ::std::string& skirt_flags() const;
  void set_skirt_flags(const ::std::string& value);
  #if LANG_CXX11
  void set_skirt_flags(::std::string&& value);
  #endif
  void set_skirt_flags(const char* value);
  void set_skirt_flags(const void* value, size_t size);
  ::std::string* mutable_skirt_flags();
  ::std::string* release_skirt_flags();
  void set_allocated_skirt_flags(::std::string* skirt_flags);

  // optional bytes normals_dev = 16;
  bool has_normals_dev() const;
  void clear_normals_dev();
  static const int kNormalsDevFieldNumber = 16;
  const ::std::string& normals_dev() const;
  void set_normals_dev(const ::std::string& value);
  #if LANG_CXX11
  void set_normals_dev(::std::string&& value);
  #endif
  void set_normals_dev(const char* value);
  void set_normals_dev(const void* value, size_t size);
  ::std::string* mutable_normals_dev();
  ::std::string* release_normals_dev();
  void set_allocated_normals_dev(::std::string* normals_dev);

  // optional uint32 mesh_id = 12;
  bool has_mesh_id() const;
  void clear_mesh_id();
  static const int kMeshIdFieldNumber = 12;
  ::google::protobuf::uint32 mesh_id() const;
  void set_mesh_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:geo_globetrotter_proto_rocktree.Mesh)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Texture > texture_;
  ::google::protobuf::RepeatedField< float > uv_offset_and_scale_;
  mutable std::atomic<int> _uv_offset_and_scale_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr vertices_;
  ::google::protobuf::internal::ArenaStringPtr texture_coords_;
  ::google::protobuf::internal::ArenaStringPtr indices_;
  ::google::protobuf::internal::ArenaStringPtr octant_ranges_;
  ::google::protobuf::internal::ArenaStringPtr layer_counts_;
  ::google::protobuf::internal::ArenaStringPtr texture_coordinates_;
  ::google::protobuf::internal::ArenaStringPtr layer_and_octant_counts_;
  ::google::protobuf::internal::ArenaStringPtr vertex_alphas_;
  ::google::protobuf::internal::ArenaStringPtr normals_;
  ::google::protobuf::internal::ArenaStringPtr skirt_flags_;
  ::google::protobuf::internal::ArenaStringPtr normals_dev_;
  ::google::protobuf::uint32 mesh_id_;
  friend struct ::TableStruct_proto_2frocktree_2eproto;
};
// -------------------------------------------------------------------

class Texture :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geo_globetrotter_proto_rocktree.Texture) */ {
 public:
  Texture();
  virtual ~Texture();

  Texture(const Texture& from);

  inline Texture& operator=(const Texture& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Texture(Texture&& from) noexcept
    : Texture() {
    *this = ::std::move(from);
  }

  inline Texture& operator=(Texture&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Texture& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Texture* internal_default_instance() {
    return reinterpret_cast<const Texture*>(
               &_Texture_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Texture* other);
  friend void swap(Texture& a, Texture& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Texture* New() const final {
    return CreateMaybeMessage<Texture>(nullptr);
  }

  Texture* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Texture>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Texture& from);
  void MergeFrom(const Texture& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Texture* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Texture_Format Format;
  static const Format JPG =
    Texture_Format_JPG;
  static const Format DXT1 =
    Texture_Format_DXT1;
  static const Format ETC1 =
    Texture_Format_ETC1;
  static const Format PVRTC2 =
    Texture_Format_PVRTC2;
  static const Format PVRTC4 =
    Texture_Format_PVRTC4;
  static const Format CRN_DXT1 =
    Texture_Format_CRN_DXT1;
  static inline bool Format_IsValid(int value) {
    return Texture_Format_IsValid(value);
  }
  static const Format Format_MIN =
    Texture_Format_Format_MIN;
  static const Format Format_MAX =
    Texture_Format_Format_MAX;
  static const int Format_ARRAYSIZE =
    Texture_Format_Format_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Format_descriptor() {
    return Texture_Format_descriptor();
  }
  static inline const ::std::string& Format_Name(Format value) {
    return Texture_Format_Name(value);
  }
  static inline bool Format_Parse(const ::std::string& name,
      Format* value) {
    return Texture_Format_Parse(name, value);
  }

  typedef Texture_ViewDirection ViewDirection;
  static const ViewDirection NADIR =
    Texture_ViewDirection_NADIR;
  static const ViewDirection NORTH_45 =
    Texture_ViewDirection_NORTH_45;
  static const ViewDirection EAST_45 =
    Texture_ViewDirection_EAST_45;
  static const ViewDirection SOUTH_45 =
    Texture_ViewDirection_SOUTH_45;
  static const ViewDirection WEST_45 =
    Texture_ViewDirection_WEST_45;
  static inline bool ViewDirection_IsValid(int value) {
    return Texture_ViewDirection_IsValid(value);
  }
  static const ViewDirection ViewDirection_MIN =
    Texture_ViewDirection_ViewDirection_MIN;
  static const ViewDirection ViewDirection_MAX =
    Texture_ViewDirection_ViewDirection_MAX;
  static const int ViewDirection_ARRAYSIZE =
    Texture_ViewDirection_ViewDirection_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ViewDirection_descriptor() {
    return Texture_ViewDirection_descriptor();
  }
  static inline const ::std::string& ViewDirection_Name(ViewDirection value) {
    return Texture_ViewDirection_Name(value);
  }
  static inline bool ViewDirection_Parse(const ::std::string& name,
      ViewDirection* value) {
    return Texture_ViewDirection_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated bytes data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data(int index) const;
  ::std::string* mutable_data(int index);
  void set_data(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_data(int index, ::std::string&& value);
  #endif
  void set_data(int index, const char* value);
  void set_data(int index, const void* value, size_t size);
  ::std::string* add_data();
  void add_data(const ::std::string& value);
  #if LANG_CXX11
  void add_data(::std::string&& value);
  #endif
  void add_data(const char* value);
  void add_data(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& data() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_data();

  // optional .geo_globetrotter_proto_rocktree.Texture.ViewDirection view_direction = 5;
  bool has_view_direction() const;
  void clear_view_direction();
  static const int kViewDirectionFieldNumber = 5;
  ::geo_globetrotter_proto_rocktree::Texture_ViewDirection view_direction() const;
  void set_view_direction(::geo_globetrotter_proto_rocktree::Texture_ViewDirection value);

  // optional uint32 mesh_id = 6;
  bool has_mesh_id() const;
  void clear_mesh_id();
  static const int kMeshIdFieldNumber = 6;
  ::google::protobuf::uint32 mesh_id() const;
  void set_mesh_id(::google::protobuf::uint32 value);

  // optional uint32 height = 4 [default = 256];
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // optional .geo_globetrotter_proto_rocktree.Texture.Format format = 2;
  bool has_format() const;
  void clear_format();
  static const int kFormatFieldNumber = 2;
  ::geo_globetrotter_proto_rocktree::Texture_Format format() const;
  void set_format(::geo_globetrotter_proto_rocktree::Texture_Format value);

  // optional uint32 width = 3 [default = 256];
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:geo_globetrotter_proto_rocktree.Texture)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField<::std::string> data_;
  int view_direction_;
  ::google::protobuf::uint32 mesh_id_;
  ::google::protobuf::uint32 height_;
  int format_;
  ::google::protobuf::uint32 width_;
  friend struct ::TableStruct_proto_2frocktree_2eproto;
};
// -------------------------------------------------------------------

class TextureData :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geo_globetrotter_proto_rocktree.TextureData) */ {
 public:
  TextureData();
  virtual ~TextureData();

  TextureData(const TextureData& from);

  inline TextureData& operator=(const TextureData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TextureData(TextureData&& from) noexcept
    : TextureData() {
    *this = ::std::move(from);
  }

  inline TextureData& operator=(TextureData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TextureData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextureData* internal_default_instance() {
    return reinterpret_cast<const TextureData*>(
               &_TextureData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(TextureData* other);
  friend void swap(TextureData& a, TextureData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TextureData* New() const final {
    return CreateMaybeMessage<TextureData>(nullptr);
  }

  TextureData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TextureData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TextureData& from);
  void MergeFrom(const TextureData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextureData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .geo_globetrotter_proto_rocktree.Texture textures = 2;
  int textures_size() const;
  void clear_textures();
  static const int kTexturesFieldNumber = 2;
  ::geo_globetrotter_proto_rocktree::Texture* mutable_textures(int index);
  ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Texture >*
      mutable_textures();
  const ::geo_globetrotter_proto_rocktree::Texture& textures(int index) const;
  ::geo_globetrotter_proto_rocktree::Texture* add_textures();
  const ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Texture >&
      textures() const;

  // optional .geo_globetrotter_proto_rocktree.NodeKey node_key = 1;
  bool has_node_key() const;
  void clear_node_key();
  static const int kNodeKeyFieldNumber = 1;
  const ::geo_globetrotter_proto_rocktree::NodeKey& node_key() const;
  ::geo_globetrotter_proto_rocktree::NodeKey* release_node_key();
  ::geo_globetrotter_proto_rocktree::NodeKey* mutable_node_key();
  void set_allocated_node_key(::geo_globetrotter_proto_rocktree::NodeKey* node_key);

  // @@protoc_insertion_point(class_scope:geo_globetrotter_proto_rocktree.TextureData)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Texture > textures_;
  ::geo_globetrotter_proto_rocktree::NodeKey* node_key_;
  friend struct ::TableStruct_proto_2frocktree_2eproto;
};
// -------------------------------------------------------------------

class Copyrights :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geo_globetrotter_proto_rocktree.Copyrights) */ {
 public:
  Copyrights();
  virtual ~Copyrights();

  Copyrights(const Copyrights& from);

  inline Copyrights& operator=(const Copyrights& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Copyrights(Copyrights&& from) noexcept
    : Copyrights() {
    *this = ::std::move(from);
  }

  inline Copyrights& operator=(Copyrights&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Copyrights& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Copyrights* internal_default_instance() {
    return reinterpret_cast<const Copyrights*>(
               &_Copyrights_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Copyrights* other);
  friend void swap(Copyrights& a, Copyrights& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Copyrights* New() const final {
    return CreateMaybeMessage<Copyrights>(nullptr);
  }

  Copyrights* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Copyrights>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Copyrights& from);
  void MergeFrom(const Copyrights& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Copyrights* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .geo_globetrotter_proto_rocktree.Copyright copyrights = 1;
  int copyrights_size() const;
  void clear_copyrights();
  static const int kCopyrightsFieldNumber = 1;
  ::geo_globetrotter_proto_rocktree::Copyright* mutable_copyrights(int index);
  ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Copyright >*
      mutable_copyrights();
  const ::geo_globetrotter_proto_rocktree::Copyright& copyrights(int index) const;
  ::geo_globetrotter_proto_rocktree::Copyright* add_copyrights();
  const ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Copyright >&
      copyrights() const;

  // @@protoc_insertion_point(class_scope:geo_globetrotter_proto_rocktree.Copyrights)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Copyright > copyrights_;
  friend struct ::TableStruct_proto_2frocktree_2eproto;
};
// -------------------------------------------------------------------

class Copyright :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geo_globetrotter_proto_rocktree.Copyright) */ {
 public:
  Copyright();
  virtual ~Copyright();

  Copyright(const Copyright& from);

  inline Copyright& operator=(const Copyright& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Copyright(Copyright&& from) noexcept
    : Copyright() {
    *this = ::std::move(from);
  }

  inline Copyright& operator=(Copyright&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Copyright& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Copyright* internal_default_instance() {
    return reinterpret_cast<const Copyright*>(
               &_Copyright_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Copyright* other);
  friend void swap(Copyright& a, Copyright& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Copyright* New() const final {
    return CreateMaybeMessage<Copyright>(nullptr);
  }

  Copyright* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Copyright>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Copyright& from);
  void MergeFrom(const Copyright& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Copyright* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 2;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional string text_clean = 3;
  bool has_text_clean() const;
  void clear_text_clean();
  static const int kTextCleanFieldNumber = 3;
  const ::std::string& text_clean() const;
  void set_text_clean(const ::std::string& value);
  #if LANG_CXX11
  void set_text_clean(::std::string&& value);
  #endif
  void set_text_clean(const char* value);
  void set_text_clean(const char* value, size_t size);
  ::std::string* mutable_text_clean();
  ::std::string* release_text_clean();
  void set_allocated_text_clean(::std::string* text_clean);

  // optional uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:geo_globetrotter_proto_rocktree.Copyright)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr text_clean_;
  ::google::protobuf::uint32 id_;
  friend struct ::TableStruct_proto_2frocktree_2eproto;
};
// -------------------------------------------------------------------

class PlanetoidMetadata :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:geo_globetrotter_proto_rocktree.PlanetoidMetadata) */ {
 public:
  PlanetoidMetadata();
  virtual ~PlanetoidMetadata();

  PlanetoidMetadata(const PlanetoidMetadata& from);

  inline PlanetoidMetadata& operator=(const PlanetoidMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlanetoidMetadata(PlanetoidMetadata&& from) noexcept
    : PlanetoidMetadata() {
    *this = ::std::move(from);
  }

  inline PlanetoidMetadata& operator=(PlanetoidMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PlanetoidMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlanetoidMetadata* internal_default_instance() {
    return reinterpret_cast<const PlanetoidMetadata*>(
               &_PlanetoidMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(PlanetoidMetadata* other);
  friend void swap(PlanetoidMetadata& a, PlanetoidMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlanetoidMetadata* New() const final {
    return CreateMaybeMessage<PlanetoidMetadata>(nullptr);
  }

  PlanetoidMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlanetoidMetadata>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlanetoidMetadata& from);
  void MergeFrom(const PlanetoidMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanetoidMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .geo_globetrotter_proto_rocktree.NodeMetadata root_node_metadata = 1;
  bool has_root_node_metadata() const;
  void clear_root_node_metadata();
  static const int kRootNodeMetadataFieldNumber = 1;
  const ::geo_globetrotter_proto_rocktree::NodeMetadata& root_node_metadata() const;
  ::geo_globetrotter_proto_rocktree::NodeMetadata* release_root_node_metadata();
  ::geo_globetrotter_proto_rocktree::NodeMetadata* mutable_root_node_metadata();
  void set_allocated_root_node_metadata(::geo_globetrotter_proto_rocktree::NodeMetadata* root_node_metadata);

  // optional float radius = 2;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 2;
  float radius() const;
  void set_radius(float value);

  // optional float min_terrain_altitude = 3;
  bool has_min_terrain_altitude() const;
  void clear_min_terrain_altitude();
  static const int kMinTerrainAltitudeFieldNumber = 3;
  float min_terrain_altitude() const;
  void set_min_terrain_altitude(float value);

  // optional float max_terrain_altitude = 4;
  bool has_max_terrain_altitude() const;
  void clear_max_terrain_altitude();
  static const int kMaxTerrainAltitudeFieldNumber = 4;
  float max_terrain_altitude() const;
  void set_max_terrain_altitude(float value);

  // @@protoc_insertion_point(class_scope:geo_globetrotter_proto_rocktree.PlanetoidMetadata)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::geo_globetrotter_proto_rocktree::NodeMetadata* root_node_metadata_;
  float radius_;
  float min_terrain_altitude_;
  float max_terrain_altitude_;
  friend struct ::TableStruct_proto_2frocktree_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BulkMetadataRequest

// optional .geo_globetrotter_proto_rocktree.NodeKey node_key = 1;
inline bool BulkMetadataRequest::has_node_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BulkMetadataRequest::clear_node_key() {
  if (node_key_ != nullptr) node_key_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::geo_globetrotter_proto_rocktree::NodeKey& BulkMetadataRequest::node_key() const {
  const ::geo_globetrotter_proto_rocktree::NodeKey* p = node_key_;
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.BulkMetadataRequest.node_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::geo_globetrotter_proto_rocktree::NodeKey*>(
      &::geo_globetrotter_proto_rocktree::_NodeKey_default_instance_);
}
inline ::geo_globetrotter_proto_rocktree::NodeKey* BulkMetadataRequest::release_node_key() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.BulkMetadataRequest.node_key)
  _has_bits_[0] &= ~0x00000001u;
  ::geo_globetrotter_proto_rocktree::NodeKey* temp = node_key_;
  node_key_ = nullptr;
  return temp;
}
inline ::geo_globetrotter_proto_rocktree::NodeKey* BulkMetadataRequest::mutable_node_key() {
  _has_bits_[0] |= 0x00000001u;
  if (node_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::geo_globetrotter_proto_rocktree::NodeKey>(GetArenaNoVirtual());
    node_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.BulkMetadataRequest.node_key)
  return node_key_;
}
inline void BulkMetadataRequest::set_allocated_node_key(::geo_globetrotter_proto_rocktree::NodeKey* node_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete node_key_;
  }
  if (node_key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      node_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  node_key_ = node_key;
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.BulkMetadataRequest.node_key)
}

// -------------------------------------------------------------------

// NodeDataRequest

// optional .geo_globetrotter_proto_rocktree.NodeKey node_key = 1;
inline bool NodeDataRequest::has_node_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeDataRequest::clear_node_key() {
  if (node_key_ != nullptr) node_key_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::geo_globetrotter_proto_rocktree::NodeKey& NodeDataRequest::node_key() const {
  const ::geo_globetrotter_proto_rocktree::NodeKey* p = node_key_;
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeDataRequest.node_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::geo_globetrotter_proto_rocktree::NodeKey*>(
      &::geo_globetrotter_proto_rocktree::_NodeKey_default_instance_);
}
inline ::geo_globetrotter_proto_rocktree::NodeKey* NodeDataRequest::release_node_key() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.NodeDataRequest.node_key)
  _has_bits_[0] &= ~0x00000001u;
  ::geo_globetrotter_proto_rocktree::NodeKey* temp = node_key_;
  node_key_ = nullptr;
  return temp;
}
inline ::geo_globetrotter_proto_rocktree::NodeKey* NodeDataRequest::mutable_node_key() {
  _has_bits_[0] |= 0x00000001u;
  if (node_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::geo_globetrotter_proto_rocktree::NodeKey>(GetArenaNoVirtual());
    node_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.NodeDataRequest.node_key)
  return node_key_;
}
inline void NodeDataRequest::set_allocated_node_key(::geo_globetrotter_proto_rocktree::NodeKey* node_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete node_key_;
  }
  if (node_key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      node_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  node_key_ = node_key;
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.NodeDataRequest.node_key)
}

// optional .geo_globetrotter_proto_rocktree.Texture.Format texture_format = 2;
inline bool NodeDataRequest::has_texture_format() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeDataRequest::clear_texture_format() {
  texture_format_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::geo_globetrotter_proto_rocktree::Texture_Format NodeDataRequest::texture_format() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeDataRequest.texture_format)
  return static_cast< ::geo_globetrotter_proto_rocktree::Texture_Format >(texture_format_);
}
inline void NodeDataRequest::set_texture_format(::geo_globetrotter_proto_rocktree::Texture_Format value) {
  assert(::geo_globetrotter_proto_rocktree::Texture_Format_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  texture_format_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.NodeDataRequest.texture_format)
}

// optional uint32 imagery_epoch = 3;
inline bool NodeDataRequest::has_imagery_epoch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeDataRequest::clear_imagery_epoch() {
  imagery_epoch_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 NodeDataRequest::imagery_epoch() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeDataRequest.imagery_epoch)
  return imagery_epoch_;
}
inline void NodeDataRequest::set_imagery_epoch(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  imagery_epoch_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.NodeDataRequest.imagery_epoch)
}

// -------------------------------------------------------------------

// NodeKey

// optional string path = 1;
inline bool NodeKey::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeKey::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& NodeKey::path() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeKey.path)
  return path_.GetNoArena();
}
inline void NodeKey::set_path(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.NodeKey.path)
}
#if LANG_CXX11
inline void NodeKey::set_path(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:geo_globetrotter_proto_rocktree.NodeKey.path)
}
#endif
inline void NodeKey::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:geo_globetrotter_proto_rocktree.NodeKey.path)
}
inline void NodeKey::set_path(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:geo_globetrotter_proto_rocktree.NodeKey.path)
}
inline ::std::string* NodeKey::mutable_path() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.NodeKey.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeKey::release_path() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.NodeKey.path)
  if (!has_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeKey::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.NodeKey.path)
}

// optional uint32 epoch = 2;
inline bool NodeKey::has_epoch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeKey::clear_epoch() {
  epoch_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 NodeKey::epoch() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeKey.epoch)
  return epoch_;
}
inline void NodeKey::set_epoch(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  epoch_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.NodeKey.epoch)
}

// -------------------------------------------------------------------

// CopyrightRequest

// optional uint32 epoch = 1;
inline bool CopyrightRequest::has_epoch() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CopyrightRequest::clear_epoch() {
  epoch_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 CopyrightRequest::epoch() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.CopyrightRequest.epoch)
  return epoch_;
}
inline void CopyrightRequest::set_epoch(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  epoch_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.CopyrightRequest.epoch)
}

// -------------------------------------------------------------------

// TextureDataRequest

// optional .geo_globetrotter_proto_rocktree.NodeKey node_key = 1;
inline bool TextureDataRequest::has_node_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextureDataRequest::clear_node_key() {
  if (node_key_ != nullptr) node_key_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::geo_globetrotter_proto_rocktree::NodeKey& TextureDataRequest::node_key() const {
  const ::geo_globetrotter_proto_rocktree::NodeKey* p = node_key_;
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.TextureDataRequest.node_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::geo_globetrotter_proto_rocktree::NodeKey*>(
      &::geo_globetrotter_proto_rocktree::_NodeKey_default_instance_);
}
inline ::geo_globetrotter_proto_rocktree::NodeKey* TextureDataRequest::release_node_key() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.TextureDataRequest.node_key)
  _has_bits_[0] &= ~0x00000001u;
  ::geo_globetrotter_proto_rocktree::NodeKey* temp = node_key_;
  node_key_ = nullptr;
  return temp;
}
inline ::geo_globetrotter_proto_rocktree::NodeKey* TextureDataRequest::mutable_node_key() {
  _has_bits_[0] |= 0x00000001u;
  if (node_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::geo_globetrotter_proto_rocktree::NodeKey>(GetArenaNoVirtual());
    node_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.TextureDataRequest.node_key)
  return node_key_;
}
inline void TextureDataRequest::set_allocated_node_key(::geo_globetrotter_proto_rocktree::NodeKey* node_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete node_key_;
  }
  if (node_key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      node_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  node_key_ = node_key;
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.TextureDataRequest.node_key)
}

// optional .geo_globetrotter_proto_rocktree.Texture.Format texture_format = 2;
inline bool TextureDataRequest::has_texture_format() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TextureDataRequest::clear_texture_format() {
  texture_format_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::geo_globetrotter_proto_rocktree::Texture_Format TextureDataRequest::texture_format() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.TextureDataRequest.texture_format)
  return static_cast< ::geo_globetrotter_proto_rocktree::Texture_Format >(texture_format_);
}
inline void TextureDataRequest::set_texture_format(::geo_globetrotter_proto_rocktree::Texture_Format value) {
  assert(::geo_globetrotter_proto_rocktree::Texture_Format_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  texture_format_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.TextureDataRequest.texture_format)
}

// optional .geo_globetrotter_proto_rocktree.Texture.ViewDirection view_direction = 3;
inline bool TextureDataRequest::has_view_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextureDataRequest::clear_view_direction() {
  view_direction_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::geo_globetrotter_proto_rocktree::Texture_ViewDirection TextureDataRequest::view_direction() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.TextureDataRequest.view_direction)
  return static_cast< ::geo_globetrotter_proto_rocktree::Texture_ViewDirection >(view_direction_);
}
inline void TextureDataRequest::set_view_direction(::geo_globetrotter_proto_rocktree::Texture_ViewDirection value) {
  assert(::geo_globetrotter_proto_rocktree::Texture_ViewDirection_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  view_direction_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.TextureDataRequest.view_direction)
}

// -------------------------------------------------------------------

// BulkMetadata

// repeated .geo_globetrotter_proto_rocktree.NodeMetadata node_metadata = 1;
inline int BulkMetadata::node_metadata_size() const {
  return node_metadata_.size();
}
inline void BulkMetadata::clear_node_metadata() {
  node_metadata_.Clear();
}
inline ::geo_globetrotter_proto_rocktree::NodeMetadata* BulkMetadata::mutable_node_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.BulkMetadata.node_metadata)
  return node_metadata_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::NodeMetadata >*
BulkMetadata::mutable_node_metadata() {
  // @@protoc_insertion_point(field_mutable_list:geo_globetrotter_proto_rocktree.BulkMetadata.node_metadata)
  return &node_metadata_;
}
inline const ::geo_globetrotter_proto_rocktree::NodeMetadata& BulkMetadata::node_metadata(int index) const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.BulkMetadata.node_metadata)
  return node_metadata_.Get(index);
}
inline ::geo_globetrotter_proto_rocktree::NodeMetadata* BulkMetadata::add_node_metadata() {
  // @@protoc_insertion_point(field_add:geo_globetrotter_proto_rocktree.BulkMetadata.node_metadata)
  return node_metadata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::NodeMetadata >&
BulkMetadata::node_metadata() const {
  // @@protoc_insertion_point(field_list:geo_globetrotter_proto_rocktree.BulkMetadata.node_metadata)
  return node_metadata_;
}

// optional .geo_globetrotter_proto_rocktree.NodeKey head_node_key = 2;
inline bool BulkMetadata::has_head_node_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BulkMetadata::clear_head_node_key() {
  if (head_node_key_ != nullptr) head_node_key_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::geo_globetrotter_proto_rocktree::NodeKey& BulkMetadata::head_node_key() const {
  const ::geo_globetrotter_proto_rocktree::NodeKey* p = head_node_key_;
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.BulkMetadata.head_node_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::geo_globetrotter_proto_rocktree::NodeKey*>(
      &::geo_globetrotter_proto_rocktree::_NodeKey_default_instance_);
}
inline ::geo_globetrotter_proto_rocktree::NodeKey* BulkMetadata::release_head_node_key() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.BulkMetadata.head_node_key)
  _has_bits_[0] &= ~0x00000001u;
  ::geo_globetrotter_proto_rocktree::NodeKey* temp = head_node_key_;
  head_node_key_ = nullptr;
  return temp;
}
inline ::geo_globetrotter_proto_rocktree::NodeKey* BulkMetadata::mutable_head_node_key() {
  _has_bits_[0] |= 0x00000001u;
  if (head_node_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::geo_globetrotter_proto_rocktree::NodeKey>(GetArenaNoVirtual());
    head_node_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.BulkMetadata.head_node_key)
  return head_node_key_;
}
inline void BulkMetadata::set_allocated_head_node_key(::geo_globetrotter_proto_rocktree::NodeKey* head_node_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete head_node_key_;
  }
  if (head_node_key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      head_node_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, head_node_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  head_node_key_ = head_node_key;
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.BulkMetadata.head_node_key)
}

// repeated double head_node_center = 3 [packed = true];
inline int BulkMetadata::head_node_center_size() const {
  return head_node_center_.size();
}
inline void BulkMetadata::clear_head_node_center() {
  head_node_center_.Clear();
}
inline double BulkMetadata::head_node_center(int index) const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.BulkMetadata.head_node_center)
  return head_node_center_.Get(index);
}
inline void BulkMetadata::set_head_node_center(int index, double value) {
  head_node_center_.Set(index, value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.BulkMetadata.head_node_center)
}
inline void BulkMetadata::add_head_node_center(double value) {
  head_node_center_.Add(value);
  // @@protoc_insertion_point(field_add:geo_globetrotter_proto_rocktree.BulkMetadata.head_node_center)
}
inline const ::google::protobuf::RepeatedField< double >&
BulkMetadata::head_node_center() const {
  // @@protoc_insertion_point(field_list:geo_globetrotter_proto_rocktree.BulkMetadata.head_node_center)
  return head_node_center_;
}
inline ::google::protobuf::RepeatedField< double >*
BulkMetadata::mutable_head_node_center() {
  // @@protoc_insertion_point(field_mutable_list:geo_globetrotter_proto_rocktree.BulkMetadata.head_node_center)
  return &head_node_center_;
}

// repeated float meters_per_texel = 4 [packed = true];
inline int BulkMetadata::meters_per_texel_size() const {
  return meters_per_texel_.size();
}
inline void BulkMetadata::clear_meters_per_texel() {
  meters_per_texel_.Clear();
}
inline float BulkMetadata::meters_per_texel(int index) const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.BulkMetadata.meters_per_texel)
  return meters_per_texel_.Get(index);
}
inline void BulkMetadata::set_meters_per_texel(int index, float value) {
  meters_per_texel_.Set(index, value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.BulkMetadata.meters_per_texel)
}
inline void BulkMetadata::add_meters_per_texel(float value) {
  meters_per_texel_.Add(value);
  // @@protoc_insertion_point(field_add:geo_globetrotter_proto_rocktree.BulkMetadata.meters_per_texel)
}
inline const ::google::protobuf::RepeatedField< float >&
BulkMetadata::meters_per_texel() const {
  // @@protoc_insertion_point(field_list:geo_globetrotter_proto_rocktree.BulkMetadata.meters_per_texel)
  return meters_per_texel_;
}
inline ::google::protobuf::RepeatedField< float >*
BulkMetadata::mutable_meters_per_texel() {
  // @@protoc_insertion_point(field_mutable_list:geo_globetrotter_proto_rocktree.BulkMetadata.meters_per_texel)
  return &meters_per_texel_;
}

// optional uint32 default_imagery_epoch = 5;
inline bool BulkMetadata::has_default_imagery_epoch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BulkMetadata::clear_default_imagery_epoch() {
  default_imagery_epoch_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 BulkMetadata::default_imagery_epoch() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.BulkMetadata.default_imagery_epoch)
  return default_imagery_epoch_;
}
inline void BulkMetadata::set_default_imagery_epoch(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  default_imagery_epoch_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.BulkMetadata.default_imagery_epoch)
}

// optional uint32 default_available_texture_formats = 6;
inline bool BulkMetadata::has_default_available_texture_formats() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BulkMetadata::clear_default_available_texture_formats() {
  default_available_texture_formats_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 BulkMetadata::default_available_texture_formats() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.BulkMetadata.default_available_texture_formats)
  return default_available_texture_formats_;
}
inline void BulkMetadata::set_default_available_texture_formats(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  default_available_texture_formats_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.BulkMetadata.default_available_texture_formats)
}

// optional uint32 default_available_view_dependent_textures = 7;
inline bool BulkMetadata::has_default_available_view_dependent_textures() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BulkMetadata::clear_default_available_view_dependent_textures() {
  default_available_view_dependent_textures_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 BulkMetadata::default_available_view_dependent_textures() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.BulkMetadata.default_available_view_dependent_textures)
  return default_available_view_dependent_textures_;
}
inline void BulkMetadata::set_default_available_view_dependent_textures(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  default_available_view_dependent_textures_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.BulkMetadata.default_available_view_dependent_textures)
}

// optional uint32 default_available_view_dependent_texture_formats = 8;
inline bool BulkMetadata::has_default_available_view_dependent_texture_formats() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BulkMetadata::clear_default_available_view_dependent_texture_formats() {
  default_available_view_dependent_texture_formats_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 BulkMetadata::default_available_view_dependent_texture_formats() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.BulkMetadata.default_available_view_dependent_texture_formats)
  return default_available_view_dependent_texture_formats_;
}
inline void BulkMetadata::set_default_available_view_dependent_texture_formats(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  default_available_view_dependent_texture_formats_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.BulkMetadata.default_available_view_dependent_texture_formats)
}

// -------------------------------------------------------------------

// NodeMetadata

// optional uint32 path_and_flags = 1;
inline bool NodeMetadata::has_path_and_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeMetadata::clear_path_and_flags() {
  path_and_flags_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 NodeMetadata::path_and_flags() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeMetadata.path_and_flags)
  return path_and_flags_;
}
inline void NodeMetadata::set_path_and_flags(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  path_and_flags_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.NodeMetadata.path_and_flags)
}

// optional uint32 epoch = 2;
inline bool NodeMetadata::has_epoch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeMetadata::clear_epoch() {
  epoch_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 NodeMetadata::epoch() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeMetadata.epoch)
  return epoch_;
}
inline void NodeMetadata::set_epoch(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  epoch_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.NodeMetadata.epoch)
}

// optional uint32 bulk_metadata_epoch = 5;
inline bool NodeMetadata::has_bulk_metadata_epoch() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NodeMetadata::clear_bulk_metadata_epoch() {
  bulk_metadata_epoch_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 NodeMetadata::bulk_metadata_epoch() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeMetadata.bulk_metadata_epoch)
  return bulk_metadata_epoch_;
}
inline void NodeMetadata::set_bulk_metadata_epoch(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  bulk_metadata_epoch_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.NodeMetadata.bulk_metadata_epoch)
}

// optional bytes oriented_bounding_box = 3;
inline bool NodeMetadata::has_oriented_bounding_box() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeMetadata::clear_oriented_bounding_box() {
  oriented_bounding_box_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& NodeMetadata::oriented_bounding_box() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeMetadata.oriented_bounding_box)
  return oriented_bounding_box_.GetNoArena();
}
inline void NodeMetadata::set_oriented_bounding_box(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  oriented_bounding_box_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.NodeMetadata.oriented_bounding_box)
}
#if LANG_CXX11
inline void NodeMetadata::set_oriented_bounding_box(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  oriented_bounding_box_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:geo_globetrotter_proto_rocktree.NodeMetadata.oriented_bounding_box)
}
#endif
inline void NodeMetadata::set_oriented_bounding_box(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  oriented_bounding_box_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:geo_globetrotter_proto_rocktree.NodeMetadata.oriented_bounding_box)
}
inline void NodeMetadata::set_oriented_bounding_box(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  oriented_bounding_box_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:geo_globetrotter_proto_rocktree.NodeMetadata.oriented_bounding_box)
}
inline ::std::string* NodeMetadata::mutable_oriented_bounding_box() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.NodeMetadata.oriented_bounding_box)
  return oriented_bounding_box_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeMetadata::release_oriented_bounding_box() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.NodeMetadata.oriented_bounding_box)
  if (!has_oriented_bounding_box()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return oriented_bounding_box_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeMetadata::set_allocated_oriented_bounding_box(::std::string* oriented_bounding_box) {
  if (oriented_bounding_box != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  oriented_bounding_box_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oriented_bounding_box);
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.NodeMetadata.oriented_bounding_box)
}

// optional float meters_per_texel = 4;
inline bool NodeMetadata::has_meters_per_texel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeMetadata::clear_meters_per_texel() {
  meters_per_texel_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float NodeMetadata::meters_per_texel() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeMetadata.meters_per_texel)
  return meters_per_texel_;
}
inline void NodeMetadata::set_meters_per_texel(float value) {
  _has_bits_[0] |= 0x00000008u;
  meters_per_texel_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.NodeMetadata.meters_per_texel)
}

// repeated double processing_oriented_bounding_box = 6 [packed = true];
inline int NodeMetadata::processing_oriented_bounding_box_size() const {
  return processing_oriented_bounding_box_.size();
}
inline void NodeMetadata::clear_processing_oriented_bounding_box() {
  processing_oriented_bounding_box_.Clear();
}
inline double NodeMetadata::processing_oriented_bounding_box(int index) const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeMetadata.processing_oriented_bounding_box)
  return processing_oriented_bounding_box_.Get(index);
}
inline void NodeMetadata::set_processing_oriented_bounding_box(int index, double value) {
  processing_oriented_bounding_box_.Set(index, value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.NodeMetadata.processing_oriented_bounding_box)
}
inline void NodeMetadata::add_processing_oriented_bounding_box(double value) {
  processing_oriented_bounding_box_.Add(value);
  // @@protoc_insertion_point(field_add:geo_globetrotter_proto_rocktree.NodeMetadata.processing_oriented_bounding_box)
}
inline const ::google::protobuf::RepeatedField< double >&
NodeMetadata::processing_oriented_bounding_box() const {
  // @@protoc_insertion_point(field_list:geo_globetrotter_proto_rocktree.NodeMetadata.processing_oriented_bounding_box)
  return processing_oriented_bounding_box_;
}
inline ::google::protobuf::RepeatedField< double >*
NodeMetadata::mutable_processing_oriented_bounding_box() {
  // @@protoc_insertion_point(field_mutable_list:geo_globetrotter_proto_rocktree.NodeMetadata.processing_oriented_bounding_box)
  return &processing_oriented_bounding_box_;
}

// optional uint32 imagery_epoch = 7;
inline bool NodeMetadata::has_imagery_epoch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NodeMetadata::clear_imagery_epoch() {
  imagery_epoch_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 NodeMetadata::imagery_epoch() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeMetadata.imagery_epoch)
  return imagery_epoch_;
}
inline void NodeMetadata::set_imagery_epoch(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  imagery_epoch_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.NodeMetadata.imagery_epoch)
}

// optional uint32 available_texture_formats = 8;
inline bool NodeMetadata::has_available_texture_formats() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NodeMetadata::clear_available_texture_formats() {
  available_texture_formats_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 NodeMetadata::available_texture_formats() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeMetadata.available_texture_formats)
  return available_texture_formats_;
}
inline void NodeMetadata::set_available_texture_formats(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  available_texture_formats_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.NodeMetadata.available_texture_formats)
}

// optional uint32 available_view_dependent_textures = 9;
inline bool NodeMetadata::has_available_view_dependent_textures() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NodeMetadata::clear_available_view_dependent_textures() {
  available_view_dependent_textures_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 NodeMetadata::available_view_dependent_textures() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeMetadata.available_view_dependent_textures)
  return available_view_dependent_textures_;
}
inline void NodeMetadata::set_available_view_dependent_textures(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  available_view_dependent_textures_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.NodeMetadata.available_view_dependent_textures)
}

// optional uint32 available_view_dependent_texture_formats = 10;
inline bool NodeMetadata::has_available_view_dependent_texture_formats() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NodeMetadata::clear_available_view_dependent_texture_formats() {
  available_view_dependent_texture_formats_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 NodeMetadata::available_view_dependent_texture_formats() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeMetadata.available_view_dependent_texture_formats)
  return available_view_dependent_texture_formats_;
}
inline void NodeMetadata::set_available_view_dependent_texture_formats(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  available_view_dependent_texture_formats_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.NodeMetadata.available_view_dependent_texture_formats)
}

// -------------------------------------------------------------------

// NodeData

// repeated double matrix_globe_from_mesh = 1 [packed = true];
inline int NodeData::matrix_globe_from_mesh_size() const {
  return matrix_globe_from_mesh_.size();
}
inline void NodeData::clear_matrix_globe_from_mesh() {
  matrix_globe_from_mesh_.Clear();
}
inline double NodeData::matrix_globe_from_mesh(int index) const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeData.matrix_globe_from_mesh)
  return matrix_globe_from_mesh_.Get(index);
}
inline void NodeData::set_matrix_globe_from_mesh(int index, double value) {
  matrix_globe_from_mesh_.Set(index, value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.NodeData.matrix_globe_from_mesh)
}
inline void NodeData::add_matrix_globe_from_mesh(double value) {
  matrix_globe_from_mesh_.Add(value);
  // @@protoc_insertion_point(field_add:geo_globetrotter_proto_rocktree.NodeData.matrix_globe_from_mesh)
}
inline const ::google::protobuf::RepeatedField< double >&
NodeData::matrix_globe_from_mesh() const {
  // @@protoc_insertion_point(field_list:geo_globetrotter_proto_rocktree.NodeData.matrix_globe_from_mesh)
  return matrix_globe_from_mesh_;
}
inline ::google::protobuf::RepeatedField< double >*
NodeData::mutable_matrix_globe_from_mesh() {
  // @@protoc_insertion_point(field_mutable_list:geo_globetrotter_proto_rocktree.NodeData.matrix_globe_from_mesh)
  return &matrix_globe_from_mesh_;
}

// repeated .geo_globetrotter_proto_rocktree.Mesh meshes = 2;
inline int NodeData::meshes_size() const {
  return meshes_.size();
}
inline void NodeData::clear_meshes() {
  meshes_.Clear();
}
inline ::geo_globetrotter_proto_rocktree::Mesh* NodeData::mutable_meshes(int index) {
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.NodeData.meshes)
  return meshes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Mesh >*
NodeData::mutable_meshes() {
  // @@protoc_insertion_point(field_mutable_list:geo_globetrotter_proto_rocktree.NodeData.meshes)
  return &meshes_;
}
inline const ::geo_globetrotter_proto_rocktree::Mesh& NodeData::meshes(int index) const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeData.meshes)
  return meshes_.Get(index);
}
inline ::geo_globetrotter_proto_rocktree::Mesh* NodeData::add_meshes() {
  // @@protoc_insertion_point(field_add:geo_globetrotter_proto_rocktree.NodeData.meshes)
  return meshes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Mesh >&
NodeData::meshes() const {
  // @@protoc_insertion_point(field_list:geo_globetrotter_proto_rocktree.NodeData.meshes)
  return meshes_;
}

// repeated uint32 copyright_ids = 3;
inline int NodeData::copyright_ids_size() const {
  return copyright_ids_.size();
}
inline void NodeData::clear_copyright_ids() {
  copyright_ids_.Clear();
}
inline ::google::protobuf::uint32 NodeData::copyright_ids(int index) const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeData.copyright_ids)
  return copyright_ids_.Get(index);
}
inline void NodeData::set_copyright_ids(int index, ::google::protobuf::uint32 value) {
  copyright_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.NodeData.copyright_ids)
}
inline void NodeData::add_copyright_ids(::google::protobuf::uint32 value) {
  copyright_ids_.Add(value);
  // @@protoc_insertion_point(field_add:geo_globetrotter_proto_rocktree.NodeData.copyright_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
NodeData::copyright_ids() const {
  // @@protoc_insertion_point(field_list:geo_globetrotter_proto_rocktree.NodeData.copyright_ids)
  return copyright_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
NodeData::mutable_copyright_ids() {
  // @@protoc_insertion_point(field_mutable_list:geo_globetrotter_proto_rocktree.NodeData.copyright_ids)
  return &copyright_ids_;
}

// optional .geo_globetrotter_proto_rocktree.NodeKey node_key = 4;
inline bool NodeData::has_node_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeData::clear_node_key() {
  if (node_key_ != nullptr) node_key_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::geo_globetrotter_proto_rocktree::NodeKey& NodeData::node_key() const {
  const ::geo_globetrotter_proto_rocktree::NodeKey* p = node_key_;
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeData.node_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::geo_globetrotter_proto_rocktree::NodeKey*>(
      &::geo_globetrotter_proto_rocktree::_NodeKey_default_instance_);
}
inline ::geo_globetrotter_proto_rocktree::NodeKey* NodeData::release_node_key() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.NodeData.node_key)
  _has_bits_[0] &= ~0x00000001u;
  ::geo_globetrotter_proto_rocktree::NodeKey* temp = node_key_;
  node_key_ = nullptr;
  return temp;
}
inline ::geo_globetrotter_proto_rocktree::NodeKey* NodeData::mutable_node_key() {
  _has_bits_[0] |= 0x00000001u;
  if (node_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::geo_globetrotter_proto_rocktree::NodeKey>(GetArenaNoVirtual());
    node_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.NodeData.node_key)
  return node_key_;
}
inline void NodeData::set_allocated_node_key(::geo_globetrotter_proto_rocktree::NodeKey* node_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete node_key_;
  }
  if (node_key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      node_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  node_key_ = node_key;
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.NodeData.node_key)
}

// repeated double kml_bounding_box = 5 [packed = true];
inline int NodeData::kml_bounding_box_size() const {
  return kml_bounding_box_.size();
}
inline void NodeData::clear_kml_bounding_box() {
  kml_bounding_box_.Clear();
}
inline double NodeData::kml_bounding_box(int index) const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeData.kml_bounding_box)
  return kml_bounding_box_.Get(index);
}
inline void NodeData::set_kml_bounding_box(int index, double value) {
  kml_bounding_box_.Set(index, value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.NodeData.kml_bounding_box)
}
inline void NodeData::add_kml_bounding_box(double value) {
  kml_bounding_box_.Add(value);
  // @@protoc_insertion_point(field_add:geo_globetrotter_proto_rocktree.NodeData.kml_bounding_box)
}
inline const ::google::protobuf::RepeatedField< double >&
NodeData::kml_bounding_box() const {
  // @@protoc_insertion_point(field_list:geo_globetrotter_proto_rocktree.NodeData.kml_bounding_box)
  return kml_bounding_box_;
}
inline ::google::protobuf::RepeatedField< double >*
NodeData::mutable_kml_bounding_box() {
  // @@protoc_insertion_point(field_mutable_list:geo_globetrotter_proto_rocktree.NodeData.kml_bounding_box)
  return &kml_bounding_box_;
}

// optional .geo_globetrotter_proto_rocktree.Mesh water_mesh = 6;
inline bool NodeData::has_water_mesh() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeData::clear_water_mesh() {
  if (water_mesh_ != nullptr) water_mesh_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::geo_globetrotter_proto_rocktree::Mesh& NodeData::water_mesh() const {
  const ::geo_globetrotter_proto_rocktree::Mesh* p = water_mesh_;
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeData.water_mesh)
  return p != nullptr ? *p : *reinterpret_cast<const ::geo_globetrotter_proto_rocktree::Mesh*>(
      &::geo_globetrotter_proto_rocktree::_Mesh_default_instance_);
}
inline ::geo_globetrotter_proto_rocktree::Mesh* NodeData::release_water_mesh() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.NodeData.water_mesh)
  _has_bits_[0] &= ~0x00000002u;
  ::geo_globetrotter_proto_rocktree::Mesh* temp = water_mesh_;
  water_mesh_ = nullptr;
  return temp;
}
inline ::geo_globetrotter_proto_rocktree::Mesh* NodeData::mutable_water_mesh() {
  _has_bits_[0] |= 0x00000002u;
  if (water_mesh_ == nullptr) {
    auto* p = CreateMaybeMessage<::geo_globetrotter_proto_rocktree::Mesh>(GetArenaNoVirtual());
    water_mesh_ = p;
  }
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.NodeData.water_mesh)
  return water_mesh_;
}
inline void NodeData::set_allocated_water_mesh(::geo_globetrotter_proto_rocktree::Mesh* water_mesh) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete water_mesh_;
  }
  if (water_mesh) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      water_mesh = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, water_mesh, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  water_mesh_ = water_mesh;
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.NodeData.water_mesh)
}

// repeated .geo_globetrotter_proto_rocktree.Mesh overlay_surface_meshes = 7;
inline int NodeData::overlay_surface_meshes_size() const {
  return overlay_surface_meshes_.size();
}
inline void NodeData::clear_overlay_surface_meshes() {
  overlay_surface_meshes_.Clear();
}
inline ::geo_globetrotter_proto_rocktree::Mesh* NodeData::mutable_overlay_surface_meshes(int index) {
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.NodeData.overlay_surface_meshes)
  return overlay_surface_meshes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Mesh >*
NodeData::mutable_overlay_surface_meshes() {
  // @@protoc_insertion_point(field_mutable_list:geo_globetrotter_proto_rocktree.NodeData.overlay_surface_meshes)
  return &overlay_surface_meshes_;
}
inline const ::geo_globetrotter_proto_rocktree::Mesh& NodeData::overlay_surface_meshes(int index) const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.NodeData.overlay_surface_meshes)
  return overlay_surface_meshes_.Get(index);
}
inline ::geo_globetrotter_proto_rocktree::Mesh* NodeData::add_overlay_surface_meshes() {
  // @@protoc_insertion_point(field_add:geo_globetrotter_proto_rocktree.NodeData.overlay_surface_meshes)
  return overlay_surface_meshes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Mesh >&
NodeData::overlay_surface_meshes() const {
  // @@protoc_insertion_point(field_list:geo_globetrotter_proto_rocktree.NodeData.overlay_surface_meshes)
  return overlay_surface_meshes_;
}

// -------------------------------------------------------------------

// Mesh

// optional bytes vertices = 1;
inline bool Mesh::has_vertices() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mesh::clear_vertices() {
  vertices_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Mesh::vertices() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Mesh.vertices)
  return vertices_.GetNoArena();
}
inline void Mesh::set_vertices(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  vertices_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Mesh.vertices)
}
#if LANG_CXX11
inline void Mesh::set_vertices(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  vertices_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:geo_globetrotter_proto_rocktree.Mesh.vertices)
}
#endif
inline void Mesh::set_vertices(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  vertices_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:geo_globetrotter_proto_rocktree.Mesh.vertices)
}
inline void Mesh::set_vertices(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  vertices_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:geo_globetrotter_proto_rocktree.Mesh.vertices)
}
inline ::std::string* Mesh::mutable_vertices() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.Mesh.vertices)
  return vertices_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mesh::release_vertices() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.Mesh.vertices)
  if (!has_vertices()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return vertices_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mesh::set_allocated_vertices(::std::string* vertices) {
  if (vertices != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  vertices_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vertices);
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.Mesh.vertices)
}

// optional bytes vertex_alphas = 9;
inline bool Mesh::has_vertex_alphas() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Mesh::clear_vertex_alphas() {
  vertex_alphas_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::std::string& Mesh::vertex_alphas() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Mesh.vertex_alphas)
  return vertex_alphas_.GetNoArena();
}
inline void Mesh::set_vertex_alphas(const ::std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  vertex_alphas_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Mesh.vertex_alphas)
}
#if LANG_CXX11
inline void Mesh::set_vertex_alphas(::std::string&& value) {
  _has_bits_[0] |= 0x00000080u;
  vertex_alphas_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:geo_globetrotter_proto_rocktree.Mesh.vertex_alphas)
}
#endif
inline void Mesh::set_vertex_alphas(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000080u;
  vertex_alphas_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:geo_globetrotter_proto_rocktree.Mesh.vertex_alphas)
}
inline void Mesh::set_vertex_alphas(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000080u;
  vertex_alphas_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:geo_globetrotter_proto_rocktree.Mesh.vertex_alphas)
}
inline ::std::string* Mesh::mutable_vertex_alphas() {
  _has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.Mesh.vertex_alphas)
  return vertex_alphas_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mesh::release_vertex_alphas() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.Mesh.vertex_alphas)
  if (!has_vertex_alphas()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return vertex_alphas_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mesh::set_allocated_vertex_alphas(::std::string* vertex_alphas) {
  if (vertex_alphas != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  vertex_alphas_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vertex_alphas);
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.Mesh.vertex_alphas)
}

// optional bytes texture_coords = 2;
inline bool Mesh::has_texture_coords() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mesh::clear_texture_coords() {
  texture_coords_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Mesh::texture_coords() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Mesh.texture_coords)
  return texture_coords_.GetNoArena();
}
inline void Mesh::set_texture_coords(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  texture_coords_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Mesh.texture_coords)
}
#if LANG_CXX11
inline void Mesh::set_texture_coords(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  texture_coords_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:geo_globetrotter_proto_rocktree.Mesh.texture_coords)
}
#endif
inline void Mesh::set_texture_coords(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  texture_coords_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:geo_globetrotter_proto_rocktree.Mesh.texture_coords)
}
inline void Mesh::set_texture_coords(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  texture_coords_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:geo_globetrotter_proto_rocktree.Mesh.texture_coords)
}
inline ::std::string* Mesh::mutable_texture_coords() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.Mesh.texture_coords)
  return texture_coords_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mesh::release_texture_coords() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.Mesh.texture_coords)
  if (!has_texture_coords()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return texture_coords_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mesh::set_allocated_texture_coords(::std::string* texture_coords) {
  if (texture_coords != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  texture_coords_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), texture_coords);
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.Mesh.texture_coords)
}

// optional bytes indices = 3;
inline bool Mesh::has_indices() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Mesh::clear_indices() {
  indices_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& Mesh::indices() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Mesh.indices)
  return indices_.GetNoArena();
}
inline void Mesh::set_indices(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  indices_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Mesh.indices)
}
#if LANG_CXX11
inline void Mesh::set_indices(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  indices_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:geo_globetrotter_proto_rocktree.Mesh.indices)
}
#endif
inline void Mesh::set_indices(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  indices_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:geo_globetrotter_proto_rocktree.Mesh.indices)
}
inline void Mesh::set_indices(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  indices_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:geo_globetrotter_proto_rocktree.Mesh.indices)
}
inline ::std::string* Mesh::mutable_indices() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.Mesh.indices)
  return indices_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mesh::release_indices() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.Mesh.indices)
  if (!has_indices()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return indices_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mesh::set_allocated_indices(::std::string* indices) {
  if (indices != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  indices_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), indices);
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.Mesh.indices)
}

// optional bytes octant_ranges = 4;
inline bool Mesh::has_octant_ranges() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Mesh::clear_octant_ranges() {
  octant_ranges_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& Mesh::octant_ranges() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Mesh.octant_ranges)
  return octant_ranges_.GetNoArena();
}
inline void Mesh::set_octant_ranges(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  octant_ranges_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Mesh.octant_ranges)
}
#if LANG_CXX11
inline void Mesh::set_octant_ranges(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  octant_ranges_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:geo_globetrotter_proto_rocktree.Mesh.octant_ranges)
}
#endif
inline void Mesh::set_octant_ranges(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  octant_ranges_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:geo_globetrotter_proto_rocktree.Mesh.octant_ranges)
}
inline void Mesh::set_octant_ranges(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  octant_ranges_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:geo_globetrotter_proto_rocktree.Mesh.octant_ranges)
}
inline ::std::string* Mesh::mutable_octant_ranges() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.Mesh.octant_ranges)
  return octant_ranges_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mesh::release_octant_ranges() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.Mesh.octant_ranges)
  if (!has_octant_ranges()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return octant_ranges_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mesh::set_allocated_octant_ranges(::std::string* octant_ranges) {
  if (octant_ranges != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  octant_ranges_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), octant_ranges);
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.Mesh.octant_ranges)
}

// optional bytes layer_counts = 5;
inline bool Mesh::has_layer_counts() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Mesh::clear_layer_counts() {
  layer_counts_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& Mesh::layer_counts() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Mesh.layer_counts)
  return layer_counts_.GetNoArena();
}
inline void Mesh::set_layer_counts(const ::std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  layer_counts_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Mesh.layer_counts)
}
#if LANG_CXX11
inline void Mesh::set_layer_counts(::std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  layer_counts_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:geo_globetrotter_proto_rocktree.Mesh.layer_counts)
}
#endif
inline void Mesh::set_layer_counts(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  layer_counts_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:geo_globetrotter_proto_rocktree.Mesh.layer_counts)
}
inline void Mesh::set_layer_counts(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  layer_counts_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:geo_globetrotter_proto_rocktree.Mesh.layer_counts)
}
inline ::std::string* Mesh::mutable_layer_counts() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.Mesh.layer_counts)
  return layer_counts_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mesh::release_layer_counts() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.Mesh.layer_counts)
  if (!has_layer_counts()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return layer_counts_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mesh::set_allocated_layer_counts(::std::string* layer_counts) {
  if (layer_counts != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  layer_counts_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), layer_counts);
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.Mesh.layer_counts)
}

// repeated .geo_globetrotter_proto_rocktree.Texture texture = 6;
inline int Mesh::texture_size() const {
  return texture_.size();
}
inline void Mesh::clear_texture() {
  texture_.Clear();
}
inline ::geo_globetrotter_proto_rocktree::Texture* Mesh::mutable_texture(int index) {
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.Mesh.texture)
  return texture_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Texture >*
Mesh::mutable_texture() {
  // @@protoc_insertion_point(field_mutable_list:geo_globetrotter_proto_rocktree.Mesh.texture)
  return &texture_;
}
inline const ::geo_globetrotter_proto_rocktree::Texture& Mesh::texture(int index) const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Mesh.texture)
  return texture_.Get(index);
}
inline ::geo_globetrotter_proto_rocktree::Texture* Mesh::add_texture() {
  // @@protoc_insertion_point(field_add:geo_globetrotter_proto_rocktree.Mesh.texture)
  return texture_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Texture >&
Mesh::texture() const {
  // @@protoc_insertion_point(field_list:geo_globetrotter_proto_rocktree.Mesh.texture)
  return texture_;
}

// optional bytes texture_coordinates = 7;
inline bool Mesh::has_texture_coordinates() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Mesh::clear_texture_coordinates() {
  texture_coordinates_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::std::string& Mesh::texture_coordinates() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Mesh.texture_coordinates)
  return texture_coordinates_.GetNoArena();
}
inline void Mesh::set_texture_coordinates(const ::std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  texture_coordinates_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Mesh.texture_coordinates)
}
#if LANG_CXX11
inline void Mesh::set_texture_coordinates(::std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  texture_coordinates_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:geo_globetrotter_proto_rocktree.Mesh.texture_coordinates)
}
#endif
inline void Mesh::set_texture_coordinates(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  texture_coordinates_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:geo_globetrotter_proto_rocktree.Mesh.texture_coordinates)
}
inline void Mesh::set_texture_coordinates(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  texture_coordinates_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:geo_globetrotter_proto_rocktree.Mesh.texture_coordinates)
}
inline ::std::string* Mesh::mutable_texture_coordinates() {
  _has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.Mesh.texture_coordinates)
  return texture_coordinates_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mesh::release_texture_coordinates() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.Mesh.texture_coordinates)
  if (!has_texture_coordinates()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return texture_coordinates_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mesh::set_allocated_texture_coordinates(::std::string* texture_coordinates) {
  if (texture_coordinates != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  texture_coordinates_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), texture_coordinates);
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.Mesh.texture_coordinates)
}

// repeated float uv_offset_and_scale = 10 [packed = true];
inline int Mesh::uv_offset_and_scale_size() const {
  return uv_offset_and_scale_.size();
}
inline void Mesh::clear_uv_offset_and_scale() {
  uv_offset_and_scale_.Clear();
}
inline float Mesh::uv_offset_and_scale(int index) const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Mesh.uv_offset_and_scale)
  return uv_offset_and_scale_.Get(index);
}
inline void Mesh::set_uv_offset_and_scale(int index, float value) {
  uv_offset_and_scale_.Set(index, value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Mesh.uv_offset_and_scale)
}
inline void Mesh::add_uv_offset_and_scale(float value) {
  uv_offset_and_scale_.Add(value);
  // @@protoc_insertion_point(field_add:geo_globetrotter_proto_rocktree.Mesh.uv_offset_and_scale)
}
inline const ::google::protobuf::RepeatedField< float >&
Mesh::uv_offset_and_scale() const {
  // @@protoc_insertion_point(field_list:geo_globetrotter_proto_rocktree.Mesh.uv_offset_and_scale)
  return uv_offset_and_scale_;
}
inline ::google::protobuf::RepeatedField< float >*
Mesh::mutable_uv_offset_and_scale() {
  // @@protoc_insertion_point(field_mutable_list:geo_globetrotter_proto_rocktree.Mesh.uv_offset_and_scale)
  return &uv_offset_and_scale_;
}

// optional bytes layer_and_octant_counts = 8;
inline bool Mesh::has_layer_and_octant_counts() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Mesh::clear_layer_and_octant_counts() {
  layer_and_octant_counts_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::std::string& Mesh::layer_and_octant_counts() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Mesh.layer_and_octant_counts)
  return layer_and_octant_counts_.GetNoArena();
}
inline void Mesh::set_layer_and_octant_counts(const ::std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  layer_and_octant_counts_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Mesh.layer_and_octant_counts)
}
#if LANG_CXX11
inline void Mesh::set_layer_and_octant_counts(::std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  layer_and_octant_counts_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:geo_globetrotter_proto_rocktree.Mesh.layer_and_octant_counts)
}
#endif
inline void Mesh::set_layer_and_octant_counts(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  layer_and_octant_counts_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:geo_globetrotter_proto_rocktree.Mesh.layer_and_octant_counts)
}
inline void Mesh::set_layer_and_octant_counts(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000040u;
  layer_and_octant_counts_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:geo_globetrotter_proto_rocktree.Mesh.layer_and_octant_counts)
}
inline ::std::string* Mesh::mutable_layer_and_octant_counts() {
  _has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.Mesh.layer_and_octant_counts)
  return layer_and_octant_counts_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mesh::release_layer_and_octant_counts() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.Mesh.layer_and_octant_counts)
  if (!has_layer_and_octant_counts()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return layer_and_octant_counts_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mesh::set_allocated_layer_and_octant_counts(::std::string* layer_and_octant_counts) {
  if (layer_and_octant_counts != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  layer_and_octant_counts_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), layer_and_octant_counts);
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.Mesh.layer_and_octant_counts)
}

// optional bytes normals = 11;
inline bool Mesh::has_normals() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Mesh::clear_normals() {
  normals_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::std::string& Mesh::normals() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Mesh.normals)
  return normals_.GetNoArena();
}
inline void Mesh::set_normals(const ::std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  normals_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Mesh.normals)
}
#if LANG_CXX11
inline void Mesh::set_normals(::std::string&& value) {
  _has_bits_[0] |= 0x00000100u;
  normals_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:geo_globetrotter_proto_rocktree.Mesh.normals)
}
#endif
inline void Mesh::set_normals(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000100u;
  normals_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:geo_globetrotter_proto_rocktree.Mesh.normals)
}
inline void Mesh::set_normals(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000100u;
  normals_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:geo_globetrotter_proto_rocktree.Mesh.normals)
}
inline ::std::string* Mesh::mutable_normals() {
  _has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.Mesh.normals)
  return normals_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mesh::release_normals() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.Mesh.normals)
  if (!has_normals()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  return normals_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mesh::set_allocated_normals(::std::string* normals) {
  if (normals != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  normals_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), normals);
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.Mesh.normals)
}

// optional bytes normals_dev = 16;
inline bool Mesh::has_normals_dev() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Mesh::clear_normals_dev() {
  normals_dev_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::std::string& Mesh::normals_dev() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Mesh.normals_dev)
  return normals_dev_.GetNoArena();
}
inline void Mesh::set_normals_dev(const ::std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  normals_dev_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Mesh.normals_dev)
}
#if LANG_CXX11
inline void Mesh::set_normals_dev(::std::string&& value) {
  _has_bits_[0] |= 0x00000400u;
  normals_dev_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:geo_globetrotter_proto_rocktree.Mesh.normals_dev)
}
#endif
inline void Mesh::set_normals_dev(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000400u;
  normals_dev_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:geo_globetrotter_proto_rocktree.Mesh.normals_dev)
}
inline void Mesh::set_normals_dev(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000400u;
  normals_dev_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:geo_globetrotter_proto_rocktree.Mesh.normals_dev)
}
inline ::std::string* Mesh::mutable_normals_dev() {
  _has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.Mesh.normals_dev)
  return normals_dev_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mesh::release_normals_dev() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.Mesh.normals_dev)
  if (!has_normals_dev()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  return normals_dev_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mesh::set_allocated_normals_dev(::std::string* normals_dev) {
  if (normals_dev != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  normals_dev_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), normals_dev);
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.Mesh.normals_dev)
}

// optional uint32 mesh_id = 12;
inline bool Mesh::has_mesh_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Mesh::clear_mesh_id() {
  mesh_id_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::google::protobuf::uint32 Mesh::mesh_id() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Mesh.mesh_id)
  return mesh_id_;
}
inline void Mesh::set_mesh_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  mesh_id_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Mesh.mesh_id)
}

// optional bytes skirt_flags = 13;
inline bool Mesh::has_skirt_flags() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Mesh::clear_skirt_flags() {
  skirt_flags_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::std::string& Mesh::skirt_flags() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Mesh.skirt_flags)
  return skirt_flags_.GetNoArena();
}
inline void Mesh::set_skirt_flags(const ::std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  skirt_flags_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Mesh.skirt_flags)
}
#if LANG_CXX11
inline void Mesh::set_skirt_flags(::std::string&& value) {
  _has_bits_[0] |= 0x00000200u;
  skirt_flags_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:geo_globetrotter_proto_rocktree.Mesh.skirt_flags)
}
#endif
inline void Mesh::set_skirt_flags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000200u;
  skirt_flags_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:geo_globetrotter_proto_rocktree.Mesh.skirt_flags)
}
inline void Mesh::set_skirt_flags(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000200u;
  skirt_flags_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:geo_globetrotter_proto_rocktree.Mesh.skirt_flags)
}
inline ::std::string* Mesh::mutable_skirt_flags() {
  _has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.Mesh.skirt_flags)
  return skirt_flags_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mesh::release_skirt_flags() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.Mesh.skirt_flags)
  if (!has_skirt_flags()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  return skirt_flags_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mesh::set_allocated_skirt_flags(::std::string* skirt_flags) {
  if (skirt_flags != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  skirt_flags_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), skirt_flags);
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.Mesh.skirt_flags)
}

// -------------------------------------------------------------------

// Texture

// repeated bytes data = 1;
inline int Texture::data_size() const {
  return data_.size();
}
inline void Texture::clear_data() {
  data_.Clear();
}
inline const ::std::string& Texture::data(int index) const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Texture.data)
  return data_.Get(index);
}
inline ::std::string* Texture::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.Texture.data)
  return data_.Mutable(index);
}
inline void Texture::set_data(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Texture.data)
  data_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Texture::set_data(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Texture.data)
  data_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Texture::set_data(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:geo_globetrotter_proto_rocktree.Texture.data)
}
inline void Texture::set_data(int index, const void* value, size_t size) {
  data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:geo_globetrotter_proto_rocktree.Texture.data)
}
inline ::std::string* Texture::add_data() {
  // @@protoc_insertion_point(field_add_mutable:geo_globetrotter_proto_rocktree.Texture.data)
  return data_.Add();
}
inline void Texture::add_data(const ::std::string& value) {
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:geo_globetrotter_proto_rocktree.Texture.data)
}
#if LANG_CXX11
inline void Texture::add_data(::std::string&& value) {
  data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:geo_globetrotter_proto_rocktree.Texture.data)
}
#endif
inline void Texture::add_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:geo_globetrotter_proto_rocktree.Texture.data)
}
inline void Texture::add_data(const void* value, size_t size) {
  data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:geo_globetrotter_proto_rocktree.Texture.data)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Texture::data() const {
  // @@protoc_insertion_point(field_list:geo_globetrotter_proto_rocktree.Texture.data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Texture::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:geo_globetrotter_proto_rocktree.Texture.data)
  return &data_;
}

// optional .geo_globetrotter_proto_rocktree.Texture.Format format = 2;
inline bool Texture::has_format() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Texture::clear_format() {
  format_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::geo_globetrotter_proto_rocktree::Texture_Format Texture::format() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Texture.format)
  return static_cast< ::geo_globetrotter_proto_rocktree::Texture_Format >(format_);
}
inline void Texture::set_format(::geo_globetrotter_proto_rocktree::Texture_Format value) {
  assert(::geo_globetrotter_proto_rocktree::Texture_Format_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  format_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Texture.format)
}

// optional uint32 width = 3 [default = 256];
inline bool Texture::has_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Texture::clear_width() {
  width_ = 256u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 Texture::width() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Texture.width)
  return width_;
}
inline void Texture::set_width(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  width_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Texture.width)
}

// optional uint32 height = 4 [default = 256];
inline bool Texture::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Texture::clear_height() {
  height_ = 256u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 Texture::height() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Texture.height)
  return height_;
}
inline void Texture::set_height(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  height_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Texture.height)
}

// optional .geo_globetrotter_proto_rocktree.Texture.ViewDirection view_direction = 5;
inline bool Texture::has_view_direction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Texture::clear_view_direction() {
  view_direction_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::geo_globetrotter_proto_rocktree::Texture_ViewDirection Texture::view_direction() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Texture.view_direction)
  return static_cast< ::geo_globetrotter_proto_rocktree::Texture_ViewDirection >(view_direction_);
}
inline void Texture::set_view_direction(::geo_globetrotter_proto_rocktree::Texture_ViewDirection value) {
  assert(::geo_globetrotter_proto_rocktree::Texture_ViewDirection_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  view_direction_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Texture.view_direction)
}

// optional uint32 mesh_id = 6;
inline bool Texture::has_mesh_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Texture::clear_mesh_id() {
  mesh_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 Texture::mesh_id() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Texture.mesh_id)
  return mesh_id_;
}
inline void Texture::set_mesh_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  mesh_id_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Texture.mesh_id)
}

// -------------------------------------------------------------------

// TextureData

// optional .geo_globetrotter_proto_rocktree.NodeKey node_key = 1;
inline bool TextureData::has_node_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextureData::clear_node_key() {
  if (node_key_ != nullptr) node_key_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::geo_globetrotter_proto_rocktree::NodeKey& TextureData::node_key() const {
  const ::geo_globetrotter_proto_rocktree::NodeKey* p = node_key_;
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.TextureData.node_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::geo_globetrotter_proto_rocktree::NodeKey*>(
      &::geo_globetrotter_proto_rocktree::_NodeKey_default_instance_);
}
inline ::geo_globetrotter_proto_rocktree::NodeKey* TextureData::release_node_key() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.TextureData.node_key)
  _has_bits_[0] &= ~0x00000001u;
  ::geo_globetrotter_proto_rocktree::NodeKey* temp = node_key_;
  node_key_ = nullptr;
  return temp;
}
inline ::geo_globetrotter_proto_rocktree::NodeKey* TextureData::mutable_node_key() {
  _has_bits_[0] |= 0x00000001u;
  if (node_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::geo_globetrotter_proto_rocktree::NodeKey>(GetArenaNoVirtual());
    node_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.TextureData.node_key)
  return node_key_;
}
inline void TextureData::set_allocated_node_key(::geo_globetrotter_proto_rocktree::NodeKey* node_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete node_key_;
  }
  if (node_key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      node_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  node_key_ = node_key;
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.TextureData.node_key)
}

// repeated .geo_globetrotter_proto_rocktree.Texture textures = 2;
inline int TextureData::textures_size() const {
  return textures_.size();
}
inline void TextureData::clear_textures() {
  textures_.Clear();
}
inline ::geo_globetrotter_proto_rocktree::Texture* TextureData::mutable_textures(int index) {
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.TextureData.textures)
  return textures_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Texture >*
TextureData::mutable_textures() {
  // @@protoc_insertion_point(field_mutable_list:geo_globetrotter_proto_rocktree.TextureData.textures)
  return &textures_;
}
inline const ::geo_globetrotter_proto_rocktree::Texture& TextureData::textures(int index) const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.TextureData.textures)
  return textures_.Get(index);
}
inline ::geo_globetrotter_proto_rocktree::Texture* TextureData::add_textures() {
  // @@protoc_insertion_point(field_add:geo_globetrotter_proto_rocktree.TextureData.textures)
  return textures_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Texture >&
TextureData::textures() const {
  // @@protoc_insertion_point(field_list:geo_globetrotter_proto_rocktree.TextureData.textures)
  return textures_;
}

// -------------------------------------------------------------------

// Copyrights

// repeated .geo_globetrotter_proto_rocktree.Copyright copyrights = 1;
inline int Copyrights::copyrights_size() const {
  return copyrights_.size();
}
inline void Copyrights::clear_copyrights() {
  copyrights_.Clear();
}
inline ::geo_globetrotter_proto_rocktree::Copyright* Copyrights::mutable_copyrights(int index) {
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.Copyrights.copyrights)
  return copyrights_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Copyright >*
Copyrights::mutable_copyrights() {
  // @@protoc_insertion_point(field_mutable_list:geo_globetrotter_proto_rocktree.Copyrights.copyrights)
  return &copyrights_;
}
inline const ::geo_globetrotter_proto_rocktree::Copyright& Copyrights::copyrights(int index) const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Copyrights.copyrights)
  return copyrights_.Get(index);
}
inline ::geo_globetrotter_proto_rocktree::Copyright* Copyrights::add_copyrights() {
  // @@protoc_insertion_point(field_add:geo_globetrotter_proto_rocktree.Copyrights.copyrights)
  return copyrights_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::geo_globetrotter_proto_rocktree::Copyright >&
Copyrights::copyrights() const {
  // @@protoc_insertion_point(field_list:geo_globetrotter_proto_rocktree.Copyrights.copyrights)
  return copyrights_;
}

// -------------------------------------------------------------------

// Copyright

// optional uint32 id = 1;
inline bool Copyright::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Copyright::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 Copyright::id() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Copyright.id)
  return id_;
}
inline void Copyright::set_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  id_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Copyright.id)
}

// optional string text = 2;
inline bool Copyright::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Copyright::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Copyright::text() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Copyright.text)
  return text_.GetNoArena();
}
inline void Copyright::set_text(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Copyright.text)
}
#if LANG_CXX11
inline void Copyright::set_text(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:geo_globetrotter_proto_rocktree.Copyright.text)
}
#endif
inline void Copyright::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:geo_globetrotter_proto_rocktree.Copyright.text)
}
inline void Copyright::set_text(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:geo_globetrotter_proto_rocktree.Copyright.text)
}
inline ::std::string* Copyright::mutable_text() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.Copyright.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Copyright::release_text() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.Copyright.text)
  if (!has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return text_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Copyright::set_allocated_text(::std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.Copyright.text)
}

// optional string text_clean = 3;
inline bool Copyright::has_text_clean() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Copyright::clear_text_clean() {
  text_clean_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Copyright::text_clean() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.Copyright.text_clean)
  return text_clean_.GetNoArena();
}
inline void Copyright::set_text_clean(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  text_clean_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.Copyright.text_clean)
}
#if LANG_CXX11
inline void Copyright::set_text_clean(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  text_clean_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:geo_globetrotter_proto_rocktree.Copyright.text_clean)
}
#endif
inline void Copyright::set_text_clean(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  text_clean_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:geo_globetrotter_proto_rocktree.Copyright.text_clean)
}
inline void Copyright::set_text_clean(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  text_clean_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:geo_globetrotter_proto_rocktree.Copyright.text_clean)
}
inline ::std::string* Copyright::mutable_text_clean() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.Copyright.text_clean)
  return text_clean_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Copyright::release_text_clean() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.Copyright.text_clean)
  if (!has_text_clean()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return text_clean_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Copyright::set_allocated_text_clean(::std::string* text_clean) {
  if (text_clean != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  text_clean_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text_clean);
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.Copyright.text_clean)
}

// -------------------------------------------------------------------

// PlanetoidMetadata

// optional .geo_globetrotter_proto_rocktree.NodeMetadata root_node_metadata = 1;
inline bool PlanetoidMetadata::has_root_node_metadata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanetoidMetadata::clear_root_node_metadata() {
  if (root_node_metadata_ != nullptr) root_node_metadata_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::geo_globetrotter_proto_rocktree::NodeMetadata& PlanetoidMetadata::root_node_metadata() const {
  const ::geo_globetrotter_proto_rocktree::NodeMetadata* p = root_node_metadata_;
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.PlanetoidMetadata.root_node_metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::geo_globetrotter_proto_rocktree::NodeMetadata*>(
      &::geo_globetrotter_proto_rocktree::_NodeMetadata_default_instance_);
}
inline ::geo_globetrotter_proto_rocktree::NodeMetadata* PlanetoidMetadata::release_root_node_metadata() {
  // @@protoc_insertion_point(field_release:geo_globetrotter_proto_rocktree.PlanetoidMetadata.root_node_metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::geo_globetrotter_proto_rocktree::NodeMetadata* temp = root_node_metadata_;
  root_node_metadata_ = nullptr;
  return temp;
}
inline ::geo_globetrotter_proto_rocktree::NodeMetadata* PlanetoidMetadata::mutable_root_node_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (root_node_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::geo_globetrotter_proto_rocktree::NodeMetadata>(GetArenaNoVirtual());
    root_node_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:geo_globetrotter_proto_rocktree.PlanetoidMetadata.root_node_metadata)
  return root_node_metadata_;
}
inline void PlanetoidMetadata::set_allocated_root_node_metadata(::geo_globetrotter_proto_rocktree::NodeMetadata* root_node_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete root_node_metadata_;
  }
  if (root_node_metadata) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      root_node_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, root_node_metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  root_node_metadata_ = root_node_metadata;
  // @@protoc_insertion_point(field_set_allocated:geo_globetrotter_proto_rocktree.PlanetoidMetadata.root_node_metadata)
}

// optional float radius = 2;
inline bool PlanetoidMetadata::has_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanetoidMetadata::clear_radius() {
  radius_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float PlanetoidMetadata::radius() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.PlanetoidMetadata.radius)
  return radius_;
}
inline void PlanetoidMetadata::set_radius(float value) {
  _has_bits_[0] |= 0x00000002u;
  radius_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.PlanetoidMetadata.radius)
}

// optional float min_terrain_altitude = 3;
inline bool PlanetoidMetadata::has_min_terrain_altitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlanetoidMetadata::clear_min_terrain_altitude() {
  min_terrain_altitude_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float PlanetoidMetadata::min_terrain_altitude() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.PlanetoidMetadata.min_terrain_altitude)
  return min_terrain_altitude_;
}
inline void PlanetoidMetadata::set_min_terrain_altitude(float value) {
  _has_bits_[0] |= 0x00000004u;
  min_terrain_altitude_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.PlanetoidMetadata.min_terrain_altitude)
}

// optional float max_terrain_altitude = 4;
inline bool PlanetoidMetadata::has_max_terrain_altitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlanetoidMetadata::clear_max_terrain_altitude() {
  max_terrain_altitude_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float PlanetoidMetadata::max_terrain_altitude() const {
  // @@protoc_insertion_point(field_get:geo_globetrotter_proto_rocktree.PlanetoidMetadata.max_terrain_altitude)
  return max_terrain_altitude_;
}
inline void PlanetoidMetadata::set_max_terrain_altitude(float value) {
  _has_bits_[0] |= 0x00000008u;
  max_terrain_altitude_ = value;
  // @@protoc_insertion_point(field_set:geo_globetrotter_proto_rocktree.PlanetoidMetadata.max_terrain_altitude)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace geo_globetrotter_proto_rocktree

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::geo_globetrotter_proto_rocktree::NodeMetadata_Flags> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::geo_globetrotter_proto_rocktree::NodeMetadata_Flags>() {
  return ::geo_globetrotter_proto_rocktree::NodeMetadata_Flags_descriptor();
}
template <> struct is_proto_enum< ::geo_globetrotter_proto_rocktree::Mesh_Layer> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::geo_globetrotter_proto_rocktree::Mesh_Layer>() {
  return ::geo_globetrotter_proto_rocktree::Mesh_Layer_descriptor();
}
template <> struct is_proto_enum< ::geo_globetrotter_proto_rocktree::Mesh_LayerMask> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::geo_globetrotter_proto_rocktree::Mesh_LayerMask>() {
  return ::geo_globetrotter_proto_rocktree::Mesh_LayerMask_descriptor();
}
template <> struct is_proto_enum< ::geo_globetrotter_proto_rocktree::Texture_Format> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::geo_globetrotter_proto_rocktree::Texture_Format>() {
  return ::geo_globetrotter_proto_rocktree::Texture_Format_descriptor();
}
template <> struct is_proto_enum< ::geo_globetrotter_proto_rocktree::Texture_ViewDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::geo_globetrotter_proto_rocktree::Texture_ViewDirection>() {
  return ::geo_globetrotter_proto_rocktree::Texture_ViewDirection_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_proto_2frocktree_2eproto
